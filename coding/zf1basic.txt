Из журнала ZX Format #1,
Санкт-Петербург, 11.1995



              BASIC
       для  программистов.

       Дмитрий  Рудовский.
________________________________

   Перед Вами курс  бейсика  для
уже имеющих некоторый опыт прог-
раммистов.  Скорее это  даже  не
курс, а сборник советов и разра-
боток,  которые могут Вам приго-
диться.
   Сразу   договоримся, -  боль-
шинство  наших  программ  будут
предназначены для 48-го бейсика.
И  вот почему:  недостатки  его
редактора компенсируются автома-
тическим  вводом  ключевых слов
одним  нажатием  клавиши,  что
неоценимо при использовании  та-
ких, отнюдь не коротких,  опера-
торов как  CONTINUE,  RANDOMIZE
и т.п.
   Между тем в бейсике 128  была
сделана  попытка  создать полно-
экранный редактор, попытка, пря-
мо  скажем,  не  совсем удачная.
Набор  слов  по буквам безмерно
усложнил  написание  и  отладку
программ,  особенно для програм-
мистов,  привыкших  к  "старому
доброму" 48-му. Они и не помнят,
какие там буквы после RAND.
   Среди недостатков 128-го так-
же "парадокс REM'а", относящийся
к TR-DOS. Команда
RANDOMIZE USR 15619:REM:LOAD ...
будет  работать  только  в 128-м
бейсике.
   Исходя из этого,  за  базовый
язык мы приняли  бейсик  48.  В
каждом  конкретном случае мы бу-
дем  упоминать  об ограничениях,
накладываемых на программу  48-м
или  128-м бейсиком.  Но  хватит
об этом.  Вернемся к нашим бара-
нам.
   Сейчас мы только наметим наши
планы на будущее,  а в следующих
номерах  журнала  начнется  сам
курс.  Так что эту статью  можно
рассматривать  как  одно большое
введение.
   В этом  цикле  кроме  методов
написания довольно серьезных ве-
щей на бейсике, также будут даны
примеры  программ,  облегчающих
создание  основной  программы, и
программ,  позволяющих  ускорить
ее работу.

   Мы планируем:

- дать  примеры  сервисных прог-
рамм типа  RENUM, TRACE & SPEED
(смотри ниже) и других

- дать   описания   существующих
компиляторов встроенного бейсика

- помочь Вам в работе с расшире-
ниями языка,  такими  как  MEGA,
BETA, LASER BASIC.

   Все мысли будут  проиллюстри-
рованы примерами  с комментария-
ми.
   Также в будущем мы планируем
познакомить   Вас  с  методами
установки  и  снятия  различных
бейсиковских защит и использова-
ния  подпрограмм в машинных  ко-
дах.

   На сегодня это все.
 
 

 
 
 
Из журнала ZX Format #2,
Санкт-Петербург, 12.1995



       Б Е Й С И К
       для программистов.
              (#2)

(С)  Дм. Рудовский  1995
________________________________

   Как и было обещано в  прошлом
номере, сегодняшняя  статья  бу-
дет посвящена функциям  и  прог-
раммам, которые расширяют  стан-
дартный Basic 48.

   В этой статье речь пойдет о:
- Renumber 128-го бейсика
- Trace & Speed
- Blast Toolkit
- ZXeditor


   Начнем  с  наиболее  близкого
расширения -  Basic  128.  Един-
ственная  функция  заслуживающая
внимания - это Renumber. При вы-
зове этой функции  строки  прог-
раммы перенумеруются  начиная  с
первой с шагом 10.  Впрочем  но-
мер "первой" строки, также как и
шаг,  можно  изменить,    занеся
необходимые параметры в  систем-
ные переменные RNFIRST и  RNSTEP
( 23444/45 и  23446/47  соответ-
ственно) бейсика 128.
   Если же Вас не  удовлетворяет
такой метод (вполне понятно, что
вводить четыре POKE в  редакторе
128-го бейсика - радости  мало),
то  рекомендую   воспользоваться
либо  расширениями  стандартного
бейсика  вроде  Mega,  Beta  или
Laser Basic,  либо  расширениями
типа ZXED или  утилиты  TOOLKIT,
либо подпрограммами  из  пакетов
Supercode и Newsupercode.
   Если Вам попался  неизвестный
продукт, претендующий на  умение
перенумеровывать  программы,  то
вы можете протестировать  его  с
помощью следующего примера:

   1 LET A=10
   3 PRINT A
   4 GO SUB 19
   6 PRINT A
   8 GO TO 10
   9 PRINT "NONSENSE"
  10 RESTORE 110
  11 READ A: PRINT A
  13 STOP
  19 LET A=2*A: RETURN
 100 DATA 35
 110 DATA 50

   Запустите этот тест,  запиши-
те или запомните результаты, за-
тем перенумеруйте его  тестируе-
мым продуктом и снова запустите.
Если результаты  обоих  прогонов
совпадут - тестируемая  програм-
ма годна к применению,  иначе  -
сотрите ее с диска.
   Несколько  комментариев.  Как
Вы поняли,  этот  пример  прове-
ряет все виды адресации бейсика,
и если программа-renumber что-то
забудет, результаты работы  тес-
та резко изменятся.
   Ну а теперь перейдем к друго-
му  типу  программ - отладчикам
( Tracer'ам ).  Все   расширения
стандартного бейсика  имеют  ко-
манду  TRACE,  а  из   отдельных
программ, выполняющих  аналогич-
ные функции, мне  известен  лишь
TRACE&SPEED  Елисеева,   который
позволяет  не только  проследить
выполнение программы по операто-
рам,  но  и  практически  произ-
вольно изменять скорость ее  вы-
полнения. Об  этой  программе  я
расскажу подробнее.
   Сама программа забирает у Вас
две строки - 1 и  9999  (включе-
ние и выключение отладчика соот-
ветственно),  а  также   верхнюю
часть ОЗУ  начиная  с  61000.  К
слову, именно по  этим  причинам
свою программу надо загружать  с
помощью MERGE, a  не  LOAD,  так
как последнее приведет к  стира-
нию части отладчика и его  нера-
ботоспособности соответственно.
   Вы загрузили  отладчик,  свою
программу, а дальше как обычно -
RUN, <ENTER>. Перед Вами появит-
ся    запрос:    Input     speed
(1-Max,255-Min):  (Введите  ско-
рость (1-Макс., 255-Мин.)
   Собственно Вы вводите не ско-
рость, а коэффициент торможения.
Если Вам не хватает скорости ин-
терпретатора, то  откомпилируйте
программу (откомпилированные мо-
дули отладчик к сожалению не бе-
рет).
   Теперь об отрицательных  сто-
ронах программы:

   1.  Категорически не рекомен-
   дуется:

-  использовать в программе опе-
 ратор  STOP и другие  аварийные
 методы выхода (их надо заменять
 на GOTO 9999)
-  останавливать программу с по-
 мощью BREAK или в INPUT
-  использовать строки 1 и 9999.

   2.  Неудобства программы:

-  невозможность  останова  про-
 граммы на низких скоростях при-
 водит к усложнению отладки про-
 граммы, а  в случае   фатальной
 ошибки  (вроде 10 GO TO 10 )  к
 настоящим мукам
-  при замедлении программа  на-
 чинает  работать  рывками,  что
 создает сложности  (в  проверке
 качества вывода например).

   Если Вам все же пришлось  на-
жать BREAK, то не нажимая  ENTER
наберите GO TO 9999 для  возвра-
щения  компьютера  в  нормальный
режим работы.

   Закончив с отладчиками,  вер-
немся к  утилитам  и  рассмотрим
две из них -  ZXEDITOR  и  BLAST
TOOLKIT.
   Утилита BLAST TOOLKIT  входит
в пакет компилятора  BLAST  (мне
известен и другой TOOLKIT, ника-
кого отношения к описываемому не
имеющий) и в принципе имеет нес-
колько функций  готовящих  текст
вашей программы к компиляции.
   Правда,  я  не  видел    нор-
мальной  дисковой  версии  этого
пакета  и  поэтому  эти  функции
становятся бессмысленными и опи-
сываться здесь не будут.
   Итак Вы загрузили  TOOLKIT  и
увидели, что  внешних  изменений
не произошло,  -  TOOLKIT  защи-
щает свои коды с помощью CLEAR и
стирает загрузчик из памяти.  Но
все же рекомендую  переинсталли-
ровать  его  следующим  образом:
NEW, затем RANDOMIZE USR 60497.
   Все функции утилиты начинают-
ся с "*" и состоят из одной бук-
вы и  параметров.  Ниже  следует
описание этих функций:

   *ЕN1- редактирование  строки
        с номером N1.

   *CN1-N2,N3  -    копирование
        строк из интервала N1-N2
        в область,  начинающуюся
        со строки N3.
           При отсутствии N2 ко-
        пируется одна строка.

   *DN1-N2- удаление  строк  из
        интервала N1-N2. При от-
        сутствии  N2   удаляется
        одна строка.

   *MN1-N2,N3- перенос   строк.
        Аналогично  копированию,
        но исходные строки  уда-
        ляются.

   *RN1-N2,N3,N4 -  Перенумера-
        ция строк  из  диапазона
        N1-N2,  первой  присваи-
        вается номер N3, перену-
        мерация идет с шагом N4.
        По умолчанию N4=10.

   *FN1-N2,N$- поиск текста  N$
        в диапазоне  N1-N2.  При
        отсутствии  N$    ищется
        текст заданный  предыду-
        щими функциями *F и *S.

   *SN1-N2,N1$,N2$- аналогично
        *F, но  найденный текст
        N1$ заменяется на N2$.

   *TN- трассирование  програм-
        мы со строки N. Замедле-
        ние трассировки  -  про-
        бел, а остановка - ENTER.

   *K - удаление из текста всех
        строк REM кроме тех, ко-
        торые начинаются с !,  %
        и &. Это связано с  тем,
        что в BLAST'е REM и дан-
        ные символы  имеют  осо-
        бое значение.

   *Q - конец работы.

   В случае  выхода  из  TOOLKIT
для возвращения туда  используй-
те RANDOMIZE USR 60497

   Теперь перейдем к другой ути-
лите - ZXEDITOR.
   Эта программа, в  отличие  от
описанной выше, занимает в  бей-
сике строки, начиная с  9900,  и
добавляет к стандартному  редак-
тору Спектрума 12 новых функций,
которые задаются в режиме курсо-
ра Т. Его можно  лицезреть,  вы-
полнив команду GO TO 9900

   Вот список функций ZXEDITOR:

     A- Поиск и замена текста в
     программе. Утилита  находит
     текст,  заменяет  его,  вы-
     дает  листинги   замененных
     частей и в конце пишет  ко-
     личество выполненных замен.

     В- Объем свободной  памяти
     для бейсика.

     C- Копирование строк прог-
     раммы, аналогично TOOLKIT.

     D- Удаление группы строк.

     F- Поиск текста в програм-
     ме и листинг начиная с это-
     го текста.

     H- Эта функция  выдаст  то
     же,  что  написано   здесь,
     только покороче  и  на  ан-
     глийском языке.

     L- По  введенному   номеру
     строки выдаст  ее  адрес  в
     памяти.

     M- Перемещение строк, ана-
     логично *M в TOOLKIT.

     P- Добавление  текста    в
     строку.

     R- Перенумерация строк.

     S- Автоматический ввод но-
     мера строки. На экран выво-
     дится листинг программы,  а
     в окне  редактора  выдается
     номер вводимой строки.

     V- Список изменений.

   Теперь дополнительные поясне-
ния:
From line- со строки
To line- по строку
base- начинать с
increment- шаг
insert after- куда вставить ?
to be- на что заменить ?

   Кавычки с курсором как прави-
ло  означают   просьбу    ввести
текст.
   В конце  надо  заметить,  что
после загрузки этой программы вы
можете  удалить  строки  9990  и
9991 (использовать их).
   Но свою программу  загружайте
только с  помощью  MERGE,  иначе
работать ZXEDITOR Вы не застави-
те никакими силами.

   P.S.Если Вам известны какие-
то более крутые  утилиты,  пожа-
луйста, напишите  об  этом  нам.
________________________________





Из журнала ZX Format #3,
Санкт-Петербург, 03.1996



         Бейсик.
               #3

(C) Дм. Рудовский 1996
________________________________

   В  этой  статье речь пойдет о
компиляторах бейсика.
   Этот  раздел прикладных прог-
рамм интересен тем, что позволя-
ет  существенно  увеличить  ско-
рость  работы  бейсик-программ и
тем  самым  снять  одно из самых
серьезных  ограничений бейсика -
медлительность.
        ________________

   Компиляторы бейсикa на Спект-
руме   можно  разделить  на  две
группы:

   1. Компиляторы интерпретирую-
щего  типа. Эти компиляторы пре-
образовывают  программу в специ-
альный код, понятный управляющей
программе,  которая является уп-
рощенным  вариантом  встроенного
интерпретатора,  за  счет чего и
появляется выигрыш в скорости.
   Однако, коды скомпилированной
программы  располагают в области
бейсик-программы или  в  области
переменных,  что не дает возмож-
ности создавать оверлейные (вло-
женные) процедуры.
   2. Компиляторы транслирующего
типа.   Компиляторы  этого  типа
создают  таблицы из адресов под-
программ и размещают скомпилиро-
ванную  программу,  как правило,
по  произвольному адресу, но из-
за усложнения процедуры компиля-
ции,  занимают  больше  места  и
имеют больше ограничений.

   Теперь краткое описание преи-
муществ  и  недостатков  того  и
другого типов компиляторов.

   Компиляторы первого типа, как
правило,не только не накладывают
ограничений на применение их, но
и  позволяют  существенно расши-
рить  средства стандартного бей-
сикa.  Как пример можно привести
Laser  Basic Compiler. Кроме то-
го, они, как правило, используют
те же области, что и стандартный
бейсик  для хранения переменных,
что  позволяет  использовать без
дополнительных  сложностей  нес-
тандартные  обращения к перемен-
ным и функциям.
   К недостаткам этого типа ком-
пиляторов,  кроме указанного вы-
ше,  можно  отнести еще и невоз-
можность   создания  управляющей
программы  на  бейсикe,  и малую
эффективность   компиляции    по
объему и скорости.
   Для  пояснения немного откло-
нимся  от темы: эффективность по
объему  -  отношение длины прог-
раммы  до  компиляции  к размеру
объектного модуля.
   Эффективность  по  скорости -
отношение времени выполнения ни-
жеследующей  программы до компи-
ляции и после.
   Вот эта программа:

  10 FOR I=16384 TO 22527
  20 POKE I,255
  30 NEXT I
  40 STOP

   Засеките  время с момента на-
жатия <ENTER> и до момента появ-
ления надписи:
9 STOP statement, 40:1

   Ну, пора вернуться к компиля-
торам.  Второй  тип компиляторов
тоже  не  является  идеальным  и
единственными  его достоинствами
являются  скорость  работы и мо-
бильность кода, т.е. возможность
компиляции    практически   куда
угодно, а все остальное - сплош-
ные  недостатки.  Их  более, чем
достаточно:
   Во-первых, масса ограничений,
накладываемых   компилятором  на
программу:  один не "переварива-
ет" команду  BEEP, другой много-
мерные  массивы,  третий  вообще
целочисленный...
   Во-вторых,  из-за  сложностей
компиляции существенно вырастает
"нагрузка"  (блок кодов, необхо-
димый скомпилированной программе
для работы.)

   Теперь подробнее о конкретных
компиляторах:


          Первый Тип.

Оптимизирующий компилятор  BLAST
(должен  поставлятся в комплекте
      с утилитой TOOLKIT).

   Сразу  должен  отметить,  что
данное описание в большей степе-
ни составлено на основании книги
"Справочник  по  системным прог-
раммам 48К" фирмы СОЛОН и многое
из   изложенного   нуждается   в
экспериментальной проверке. Про-
верить   все   нижеследующее  на
практике  мне  не  удалось из-за
отсутствия  в  моем  архиве нор-
мально   дискетированной  версии
BLAST'а.
   BLAST  позволяет  скомпилиро-
вать  в  непосредственном режиме
программы  размером не более 3К.
При  больших  размерах требуется
предварительная  обработка прог-
раммы отладчиком TOOLKIT. Компи-
лятор воспринимает следующие ко-
манды:

   *C - Компиляция программы.
   *R - Старт  откомпилированной
      программы.
   *S - Запись откомпилированно-
      го модуля на диск.
   *I - Выбор входного устройст-
      ва для компиляции.
      R - память;
      E - магнитофон;
      М - микродрайв.
   *O - Выбор  выходного устрой-
      ства (аналогично входному)

   BLAST  позволяет  существенно
расширить  возможности стандарт-
ного   бейсикa,  используя  кон-
струкцию: REM option.

   Options:

   !AUTORUN - Автозапуск скомпи-
лированной  программы после заг-
рузки;
   !PCODE - Генерация защищенно-
го Pi-кода;
   !MACHINE CODE   -   Генерация
обычного кода;
   !INT  парам. - Объявление це-
лых  переменных (занимают 2 бай-
та, вместо обычных 5);
   %... - Обычный комментарий;
   &BREAK (ON/OFF) -  Включение/
выключение  останова  по клавише
BREAK.
   &WHILE   условие  -  оператор
цикла, знакомый многим по языкам
Pascal,  C. При истинности усло-
вия оператор пропускается, иначе
-  происходит  переход на опера-
тор, следующий за &WEND.
   &WEND  - действует аналогично
GO TO &WHILE и служит для указа-
ния  конца  цикла  WHILE...WEND.
   &REPEAT - На оператор, следу-
ющий за этим, происходит переход
с инструкции &UNTIL.
   &UNTIL   условие  -  оператор
аналогичный &WHILE, используется
в конструкции REPEAT...UNTIL.

   Небольшое отклонение для тех,
кто не знаком с Паскалем или С.
   В алгоритмических языках при-
нято  разделять циклы на два ти-
па: циклы с предусловием и циклы
с постусловием.
   Циклы  с предусловием (&WHILE
...WEND),  при исходном значении
условия  -  ложь, ни разу не вы-
полняются. В отличии от них,цик-
лы  с  постусловием (FOR...NEXT,
REPEAT...UNTIL) выполняются хотя
бы  один  раз, даже если условие
ложно.

   &DOKE  x,y  - Версия POKE, но
заносит в x слово (2 байта) y;
   &DEEK  x,y  - Функция, равно-
сильная:Y=256*PEEK(X+1)+PEEK(X);
   &CALL  x,[a,b,c,...]  - Вызов
подпрограммы в машинных кодах по
адресу  x,  с передачей необяза-
тельных   параметров   a,b,c,...
так, что на первый из них указы-
вает регистр IX;
   &ELSE  операторы  - Очень по-
лезное   дополнение,  существует
практически во всех версиях бей-
сикa  и используется в конструк-
ции   IF...THEN...ELSE...,   где
указывает, какие действия произ-
водить в случае невыполнения ус-
ловия после IF.

   И еще несколько тонкостей:
   1.  Скорее  всего BLAST попал
(или  попадет)  к Вам с неснятой
защитой,  с этой проблемой реко-
мендую  обратиться к упомянутому
выше источнику.
   2.  Ежели  Вам удалось отком-
пилировать   Вашу   программу  в
BLAST'е,  то  вот метод выгрузки
программы на ленту (на диск так-
же ?):

 15 LOAD "PROC"
 20 RANDOMIZE USR PEEK 23635+
     256*PEEK 23636+150: SAVE
     "PROC" LINE 15

   3.   Скомпилированный  модуль
работает  только  при  наличии в
памяти блока рабочих процедур RT
CODE.
   4.  Характеристики компилято-
ра:
Коэффициент объема: 95%
Коэффициент скорости: 145%
Размер "навески": 5К

! Описание   программы  TOOLKIT
дано во втором номере журнала.


   Компилятор бейсик-программ
     из пакета LASER BASIC
     фирмы OASIS SOFTWARE.

   Об  этом компиляторе говорить
много не буду, т.к. позднее, при
описании   самого  LASER  BASIC,
расскажу  и  о воспринимаемых им
расширениям.
   Итак,  сделав CLEAR 59799 или
ниже, мы загружаем блок компиля-
тора COMPCODE и программу; затем
запускаем  компилятор директивой
RANDOMIZE USR 59800 и ждем, пока
экран не очистится и не появится
надпись, что, дескать, все окей.
Тогда  записываем скомпилирован-
ную  программу, как бейсик-блок,
но ни в коем случае не делаем ни
RUN,  ни  CLEAR, т.к. компилятор
размещает  коды  в области пере-
менных,  и  очистка этой области
приведет  к уничтожению програм-
мы.
   Для  запуска программы повто-
ряем  те  же действия, но вместо
компилятора грузим пакет рабочих
процедур  - RTCODE. Запуск прог-
раммы - GO TO 1.
   Характеристики компилятора:
Коэффициент объема: 85-100 %
Коэффициент скорости: 130-150 %
Размер "навески": 5.7K


    Второй Тип Компиляторов.

        ZX COMPILER v1.0
      THRELFALL & HODGSON.
           1982 год.

   Сей  целочисленный компилятор
является,   наверно,  первым  из
компиляторов для Spectrum-бейси-
ка. Он далеко не самый худший на
сегодняшний день, хотя созданная
через 3 года 2 версия этого ком-
пилятора, живущая в нашей стране
под  именем  MCODER  2, работает
несколько   быстрее.   Так   как
рассказывать   об   ограничениях
этого компилятора слишком долго,
то скажу коротко - если какую-то
конструкцию  компилятор  не вос-
принимает,  он выведет ее на эк-
ран и прервет компиляцию.
   Для   компиляции   необходимо
опустить RAMTOP на уровень АДРЕС
КОМПИЛЯЦИИ-1  (этот метод приме-
няется во всех компиляторах вто-
рого  типа) и запустить компиля-
тор   командой   RANDOMIZE   USR
60000.
   Характеристики компилятора:
                  v1.0     v2.0
Коэф. объема:        140-180%
Коэф. скорости:   2200%    2500%
Размер "навески": 4.8K     4.8K


        INTEGER COMPILER
          Мартин Левис
            1983 г.

   Мартин  Левис в 1983 году вы-
пустил  компилятор,  по характе-
ристикам   равный   ZX  COMPILER
v2.0,   правда   "навеска"  была
длинней  на 0.5К, да в ходе ком-
пиляции высвечивалось меньше ин-
формации.
   В том же году Левис выпускает
и  компилятор, работающий с пла-
вающей  запятой (дробными числа-
ми). FLOATING POINT COMPILER за-
нимал   практически  столько  же
места, сколько и его целочислен-
ный   собрат,   однако,  быстро-
действие  упало в 6 раз, поэтому
если Ваша программа не пользует-
ся дробными числами использовать
сей   компилятор  представляется
неэффективным.
   Оба  эти компилятора запуска-
ются с адреса 59300.
   Характеристики FPC v1.0:
Коэффициент объема: >150%
Коэффициент скорости: 400%
Размер "навески":    5.3K


             TOBOS
 FULL FLOATING POINT COMPILER.

   Пожалуй,   это  самый  мощный
компилятор   второго   типа.  Он
практически  не ставит ограниче-
ний на компилируемую программу.
   Итак, порядок работы  с  этим
компилятором:
  1. Опускаете  RAMTOP на нужный
адрес, но не выше 50000.
  2. Загружаете компилятор.
  3. Загружаете программу, кото-
рую хотите скомпилировать.
  4. Запускаете  компилятор  ди-
рективой RANDOMIZE USR 53100.
  5. Записываете кодовый блок по
указаниям компилятора.

   Главный недостаток этого ком-
пилятора  - огромный размер "на-
вески", а также очистка всей па-
мяти между скомплированным моду-
лем и "навеской".
   Характеристики компилятора:
Коэффициент объема:  95-140%
Коэффициент скорости: 600%
Размер "навески":  12.1K

!  Внимание:
   Все  компиляторы второго типа
требуют присутствия в памяти се-
бя для нормальной работы скомпи-
лированной программы.

   P.S. Все  компиляторы  обоих
типов  не допускают работы ском-
пилированной программы с устрой-
ствами ввода/вывода (магнитофон,
дисковод),  обращение к ним воз-
можно только из машинных кодов.
________________________________






Из журнала ZX Format #4,
Санкт-Петербург, 15.06.1996



             Бейсик
              (#4)

(C) Дм. Рудовский
________________________________

   Basic,  как и все языки высо-
кого  уровня имеет несколько не-
достатков.  И  самый  главный из
них - медлительность.
   Вот самый простой пример. На-
берите программу:

  10 FOR I=0 TO 65535
  20 NEXT I
  30 CLEAR 29999
  40 PRINT "STOP TIME"
  50 FOR K=30000 TO 30009
  60 READ B: POKE K,B
  70 NEXT K
  80 STOP
 100 RANDOMIZE USR 30000
 110 GO TO 30
 120 DATA 1,255,255,11,120,177
 130 DATA 194,51,117,201

   Запустите  ее  командой  RUN,
засекая  время до появления над-
писи STOP TIME. Теперь запустите
программу  вторично,  но на этот
раз  командой  RUN  100, проведя
аналогичные операции.
   Теперь сравните. Как правило,
первый результат раз в сто боль-
ше  второго. Для тех, кто не по-
нял,  объясняю:  первый запуск -
Basic-интерпретатор  "прокрутил"
пустой цикл 65536 раз, во второй
раз  то же самое было сделано из
машинных кодов.
   Итак, Вы убедились, что Basic
слишком  медлителен.  Что же де-
лать,  если  Ваши познания в ас-
семблере  не  позволяют Вам соз-
дать  в нем какой-нибудь шедевр?
Ответ   прост:  надо  совместить
возможности  Basic  со скоростью
ассемблера.
   Вспомнив  прошлую  статью, Вы
восклицаете  "Эврика!" и бросае-
тесь искать компилятор, но проч-
тя его описание, приходите к вы-
воду  -  "Для калькулятора может
быть подойдет".
   Но все-таки не торопитесь чи-
тать раздел по ассемблеру, а до-
читайте до конца эту статью, так
как  речь в ней пойдет именно об
описанной выше проблеме.
   Функция  USR число возвращает
содержимое  регистровой пары BC,
оставшееся  там после выполнения
подпрограммы  в  машинных кодах,
расположенной по адресу, указан-
ному как параметр функции.
   Возникает  вопрос  -  неужели
элементарные   процедуры,  вроде
скроллинга,  придется писать са-
мому?
   Конечно,  нет  смысла изобре-
тать  велосипед, -  элементарные
программы уже придуманы, написа-
ны  и  собраны  в библиотеки под
названиями:
    SUPERCODE и NEWSUPERCODE.
   Все,  что  Вам нужно, так это
найти  нужную Вам процедуру, за-
писать  ее  на диск и вставить в
свою  программу.  О том, как вы-
полнить  эти три пункта и пойдет
речь в дальнейшем.

   Описывать подпрограммы в этих
пакетах я буду по порядку их но-
меров  в  Supercode 3.5, давая в
скобках   номер  соответствующей
процедуры в Newsupercode. Но пе-
ред этим я должен несколько слов
сказать   о  системе  управления
этими пакетами.

   Supercode 3.5:
   Сей  пакет  состоит  из  двух
частей  (подпрограммы  1-74, 75-
150).  После загрузки и вводного
слова на польском Вы попадаете в
меню.  Дам  расшифровку пунктов,
кои  выбираются  нажатием первой
буквы  команды.  С самого начала
Вас подстерегает странная строч-
ка внизу экрана:

  DEMO/PRNTR/QUIT/ANY OTHER KEY

где  DEMO- демонстрация возмож-
ностей программы в целом,
 PRNTR- распечатка на принтере,
 QUIT- выход в Basic,
 ANY OTHER KEY- продолжить.

   Продолжив,   мы   попадаем  в
главное меню:

 NUMBER -  описание процедуры с
номером,  который  Вас  попросят
ввести.
 DEMO- см. выше.
 PRNTR- см. выше.
 LOCATE -  объяснения,  как ис-
пользовать процедуры по адресам,
отличным  от тех, которые даны в
Supercode.
 INDEX- на страницу назад.
 JUMP PAGE#- Переход на страни-
цу n(1-4).
 CONTINUE- переход на следующую
страницу.
 SAVE -  запись нужной Вам под-
программы на диск.
 QUIT- см. выше.

   Нажав "N и набрав нужный Вам
номер  подпрограммы,  Вы увидите
ее описание и очередное меню:

EXAMPLE/PRNTR/QUIT/ANY OTHER KEY

   Из  всех пунктов новый только
один - EXAMPLE. Для слабо знако-
мых с английским объясняю -
  EXAMPLE- пример,
это  означает,  что выбирая этот
пункт  Вы  увидите пример работы
этой подпрограммы.

   Пакет Newsupercode отличается
от  Supercode только меньшим ко-
личеством  подпрограмм  и лучшим
интерфейсом. Здесь выбор осущес-
твляется  лишь курсорными клави-
шами и "ENTER". Выбираешь нужную
процедуру,  наводишь на нее кур-
сор и нажимаешь "ENTER".

   Теперь   перейдем   непосред-
ственно к самим подпрограммам. Я
приведу пример работы с ними.
   Итак,  Вы хотите чтобы в слу-
чае  ошибки программа не вывали-
валась  в Basic с никому не нуж-
ной  надписью,  а  переходила на
строку  Вашей  программы, где Вы
ее проанализируете.
   Посмотрим,  что нам для этого
нужно:

 1. Подпрограмма перехвата ошиб-
ки.
 2. Подпрограмма подачи звуково-
го сигнала.

   Теперь  загружаем Supercode и
ищем  подпрограмму с номером 65.
После  ее запуска при любом пре-
рывании  программы  (даже  О.К.)
управление будет передаваться на
определенную  строку Basic прог-
раммы, адрес которой будет задан
нами  в ячейках памяти 60878/79.
С  помощью опции SAVE записываем
эту  процедуру  на  диск. Если у
Вас кассетный вариант,то запиши-
те  на бумаге адрес и длину этой
подпрограммы и, нажав QUIT, вый-
дите  в Basic. Запишите ее обыч-
ным  способом, а затем вернитесь
в  пакет командой GO TO 0 и пов-
торите все вышеприведенные мани-
пуляции с процедурой номер 42.
   Теперь,  выйдя в Basic, набе-
рите нижеприведенную программу:

  10 CLEAR 60825
  20 RANDOMIZE USR 15619: REM :
     LOAD "65" CODE
  30 RANDOMIZE USR 15619: REM :
     LOAD "42" CODE
  40 POKE 63951,20
  50 RANDOMIZE USR 60826
  60 INPUT "INPUT N(1-5):";N
  70 RESTORE: LET SUM=0
  80 FOR I=1 TO N
  90 READ A
 100 LET SUM=SUM+A
 110 NEXT I
 120 PRINT "SUMMA ";N;"NUMBER
     =";SUM
 130 GO TO 60
9495 LET A=USR 63950
9500 LET A=PEEK 23681
9510 IF A=CODE "E" THEN GO TO
     9700
9520 PRINT "ERROR, CODE ";A
9530 GO TO 60
9700 PRINT "READ TEXT, PIG!"
9710 PRINT "EXIT?"
9720 LET K$=INKEY$: IF K$=""
     THEN GO TO 9720
9730 IF K$="D" THEN LET A=USR 0
9740 IF K$="N" THEN GO TO 60
9750 GO TO 9720

   Некоторые пояснения. В строке
40  устанавливается длительность
звукового  сигнала,  в строке 50
активизируется  подпрограмма пе-
рехвата  ошибки,  в строке 9495,
куда  происходит  переход  после
ошибки,  выдается  звуковой сиг-
нал.
   Если  Вас не устраивает такой
метод,то ждите следующей статьи,
где будет объяснено, что делать,
когда  возможности  стандартного
Basica Вас не удовлетворяют.
________________________________