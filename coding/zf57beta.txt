Из журнала ZX Format #5,
Санкт-Петербург, 12.12.1996



    Basic для чайников - 5.

(C) Д.Рудовский
________________________________

  Этой  статьей я открываю новый
большой  раздел  в этом курсе. в
этом разделе речь пойдет о прог-
раммах  называемых  расширениями
языка  Basic.  Но  на  деле  это
практически самостоятельные язы-
ки программирования. Каждое рас-
ширение   (в  дальнейшем  язык.)
имеет  свои особенности, которые
специализируют  его в определен-
ной сфере применения. При описа-
нии  языка я буду указывать наи-
более  удобное приложение языка.
Внимание!!! Все языки не работа-
ют в 128 режиме, перед загрузкой
не  забудьте перейти в 48 режим.
Ввиду большого объема информации
сегодняшнюю статью я посвящю Be-
ta-Basic'у.

          BETA-BASIC.
 
Внимание!!! Во время своей рабо-
ты  ВВ использует альтернативный
режим прерываний, из-за чего не-
возможен  прямой выход в TR-DOS.
Перед  работой прочитайте раздел
РАБОТА С TR-DOS.

           Введение.
 
  Beta-Basic  (в  дальнейшем ВВ)
является  наверно  самым  мощным
среди  расширений. Он предлагает
широчайшие  возможности в редак-
тировании  и программировании на
бейсике. Он является практически
полным   аналогом   GW-BASIC  на
IBM-совместимых  машинах. Учиты-
вая, что программа написанная на
бейсике   не   должна   занимать
больше 20К (иначе либо переходи-
те  на  IBM,  или на ассемблер),
поэтому я буду описывать ВВ 3.0,
который сам занимает 20К.
  Итак,  сначала некоторые пояс-
нения по поводу набора программы
в  ВВ: В зависимости от установ-
ленного режима, который устанав-
ливается  командой KEYWORDS опе-
раторы вводятся либо как в обыч-
ном бейсике (токенами), где опе-
раторы  ВВ  вводятся  из  режима
курсора G, либо вводятся по сим-
волам, как в Basic128. Кроме то-
го  есть возможность варьировать
вывод  программы  на экран. Под-
робнее об этом в описании опера-
тора KEYWORDS.
  Изменена  процедура  оператора
FOR  -  NEXT, в результате чего,
она работает существенно быстрее
с  целыми  числами до 65535 и не
тормозит   при  больших  номерах
строк.  Дополнен  также оператор
PRINT, о чем вы можете прочитать
в разделе ВВОД-ВЫВОД.

         Начало работы.
 
  После того как вы загрузили ВВ
загрузчик  самоликвидируется, из
него   остается  только  нулевая
строка.  Пытаться  удалить ее не
стоит, в ней хранится информация
необходимая  для работы ВВ, поэ-
тому же, перенося свою программу
в  среду ВВ загружать ее надо не
по  LOAD  а  по  MERGE Так как
программа записанная из среды ВВ
уже имеет в себе нулевую строку,
то  нет  необходимости использо-
вать MERGE.

           Редактор.
 
  Теперь  пора подробно рассмот-
реть  изменения  и  дополнения к
встроенному    редактору    бей-
сик-программ.
  Команда NEW стирает программу,
но оставляет нулевую строку, по-
этому,  если  вам  надо сбросить
ВВ,  либо  нажмите  RESET,  либо
дайте  команду  RANDOMIZE USR 0.
Изменилось    действие   команды
LIST  появились  новые команды:
EDIT RENUMи KEYWORDS
  Ну, а теперь все по порядку:
  LIST  [n,TO  m]- Вывод текста
бейсик-программы  (далее  - лис-
тинг)  со  строки  n до строки m
включительно. Пример:
LIST  100 - листинг с 100 строки
до   конца;
LIST 100 TO ---""---""---""--- ;

LIST  TO  100 - листинг до 100'й
строки;

LIST  10  TO 100 - вывод строк с
10 по 100 включительно.

LIST FORMAT n - Установка форма-
та  вывода  листинга.  n - номер
режима.
0  - Стандартный вывод листинга.
1  -  Строки выводятся по одному
оператору  в  экранной  строке и
отступом  в  операторах  FOR, GO
SUB, DEF FN и DEF PROC на 1 сим-
вол.  При  этом  режиме во время
ввода  при  нажатии  ":" следует
автоматический  сдвиг  и  символ
":" не печатается.
2  -  Аналогичен  формату  1, но
отступ берется 2 символа.
3  - Стандартный вывод листинга,
но номера строк не выводятся.
4 - Аналогичен формату 1, но без
вывода номеров строк.
5 - Аналогичен формату 2,
----""----""----""----""----
LIST  DATA |  Вывод  переменных
LIST VAL   |  программы   и  их
LIST VAL$  |  значений  в алфа-
витном  порядке. DATA - всех пе-
ременных;  VAL  - числовых пере-
менных,  массивов  и  переменных
цикла;  VAL$  -  вывод строковых
переменных и массивов. Для пере-
менных   цикла  дается  дополни-
тельно  STEP n - шаг изменения и
LN  n  - номер строки из которой
происходит возврат в голову цик-
ла.  LIST DEF KEY- вывод списка
клавиш  определенных пользовате-
лем.
LIST  PROC name- Вывод листинга
процедуры с именем name.

LIST  REF- Выдача номеров поме-
ченных строк.
Пример:
   10 FOR N=0 TO 10: PRINT N
   20 NEXT N
    Команда LIST REF N даст:
         10
         10
         20
EDIT n- Вызов на редактирование
строки  n.  Аналогично  LIST n и
<CS+1>.
RENUM[#]  [n TO m LINE k STEP l]
-  Эта  команда  выполняет  мно-
жество фукций:
переименовывает, копирует, пере-
мещает.  При этом изменяются все
ссылки   на   перенумеровываемые
строки. Назначение параметров:
# -  указывает  на то, что блок
должен быть скопирован, а не пе-
ремещен;
n- номер строки с которой начи-
нает  работать команда, по умол-
чанию - 1;
m - номер строки на которой за-
канчивает  работать  команда, по
умолчанию - 9999;
k -  новый  номер который будет
присвоен  строке n, по умолчанию
- 10;
l -  шаг,  с которым будет идти
перенумеровка  строк, по умолча-
нию - 10.
     Примеры:
RENUM  -  Перенумеровывает  всю
программу    присваивая   первой
строке номер 10 с шагом 10;

RENUM 100- перенумеровывает 100
строку присваивая ей номер 10;

RENUM  100 TO- перенумеровывает
программу  начиная с 100 строки,
которой присваивается номер 10 с
шагом 10;
RENUM TO 100- перенумеровывает-
ся  программа до 100 строки, при
этом первой строке присваивается
номер  10 и перенумеровка идет с
шагом 10;
RENUM  LINE 1000- перенумеровы-
вается вся программа с шагом 10,
при  этом первой строке присваи-
вается номер 1000;
RENUM STEP 1- вся программа пе-
ренумеровывается  с шагом 1, при
этом перовй строке присваивается
номер 10.
NB  Команда  использует  в  ка-
честве  буфера экран, поэтому во
время  ее работы на экране появ-
ляется  грязь. В случае если ко-
манде попадается инструкция типа
GO  TO ln*100 команда не исправ-
ляет ее, а выдает сообщение: Fa-
iled at n:m, где n - номер стро-
ки,  а  m  -  номер  оператора в
строке.
KEYWORDS  n -  Установка режима
ввода  программы с клавиатуры, n
- режим.
0 - В режиме курсора G вводится
UDG. 1- В режиме курсора G вво-
дятся  команды  ВВ. Режимы 0 и 1
не влияют на установку остальных
режимов.
2 - Все ключевые слова вводятся
одним  нажатием  клавиши, причем
команды  ВВ вводятся через режим
G.
3- Аналогичен режиму 2, но поз-
воляет вводить команды и по бук-
вам  NB. Для перехода от курсора
К, к курсору L нажать пробел.
4- Все команды вводятся по сим-
волам.
NB  Команда не токенизируется в
случае,  если  перед  ней  стоит
буква или "_".

        Работа с TR-DOS.
 
  Встроенные в ВВ часы использу-
ют  2 режим прерываний, что при-
водит  к  конфликту  ВВ с TR-DOS
при обращении к ней, поэтому пе-
ред  тем как выйти в TR-DOS вве-
дите команду RANDOMIZE USR 63237
для  всстановления 1 режима пре-
рываний,  а  по окончании работы
установите 2 второй режим преры-
ваний   командой  RANDOMIZE  USR
61369.
  Так   как  работать  с  диском
обычно  приходится довольно час-
то,  то  рекомендую  вставить  в
программу следующий фрагмент:
9998 RANDOMIZE USR 63237: RANDO-
MIZE USR 15616
9999 RANDOMIZE USR 61369
  Для  работы с диском дайте ко-
манду GO TO 9998. При возврате в
бейсик  все будет восстановлено.
Если  же  вы не планируете рабо-
тать  с часами ВВ, то рекомендую
сразу отключить их RANDOMIZE USR
63237  и  вы будете избавлены от
вышеописанных неприятностей.

        Вывод на экран.
 
  В   ВВ  существенно  расширены
возможности стандартного бейсика
по выводу на экран. Кроме расши-
рения  возможностей команд PRINT
и PLOTвведена команда WINDOW а
также  целый спектр команд рабо-
тающих  с  графическим  экраном.
Рссмотрим все по порядку:
PRINT:  USING "формат"- так на-
зываемый  форматированный вывод,
где  "формат" - символьная стро-
ка,  в  соответствии  с  которой
идет вывод чисел на экран.
CSIZE  n,m -  установка расмера
символа  (  в пикселях) по гори-
зонтали и вертикали. Примеры:
PRINT USING "####.##%";989.275-
Результатом будет: 989.28%
PRINT  USING "0000.000";989.2751
- Результат: 0989.275
PRINT  CSIZE 16,16;"HELLO"- вы-
ведет  на  экран  слово  "HELLO"
размером 2*2 знакоместа.
Команду CSIZEможно использовать
и  отдельно от PRINT и тогда она
задаст общий режим вывода на эк-
ран.
PLOT x,y;a$- Вывод строки a$ на
экран  с точностью до пикселя. x
и  y  расчитываются  как обычной
команде PLOT.
WINDOW n,x,y,len,hgt- Определе-
ние   окна.   n   -  номер  окна
1-127;x,y  -  координаты  левого
верхнего  угла  окна как в PLOT;
len,hgt  - длина и высота окна в
пикселях. После определения окна
его  можно  сделать текущим, дав
команду:
WINDOW  n -  где n - номер окна
(окно должно быть определено пе-
ред  этим.). Основной экран счи-
тается 0 окном.
Каждому  окну соответствуют свои
параметры,  такие  как:  позиция
печати,  размер символов, INVER-
SE,   BRIGHT,  INK,  PAPER.  Для
очистки окна нужно дать команду:
CLS  n- где n - номер окна. Для
уничтожения окна необходимо дать
команду: ERASE WINDOW n
GET a$,x,y,len,hgt,type- Данная
функция  сохраняет  экранную об-
ласть  с координатами x,y и раз-
мерами   len,hgt   в  переменной
a$.(все  задается  в  пикселях.)
Параметр   type  указывает,  как
сохранять изображение:
0- без атрибутов;
1- с атрибутами.
OVER n- эта команда бейсика до-
полнена   режимом  2:  наложение
изображения  на экран без инвер-
сии.
      Продолжение следует.
________________________________




Из журнала ZX Format #6,
Санкт-Петербург, 30.07.1997



               Beta-Basic

                Часть II

 Д.Рудовский
_________________________________________

          Процедуры и функции.

    Для тех, кто работает на бейсике, уже
знакомо  понятие  функции,  хотя  понятие
процедура   и  представляется,  наверное,
несколько  абстрактно.  Поэтому я и начну
описание именно с процедур.
    Процедура Spectrum-бейсикa была упро-
щена  до подпрограммы, которая не имеет к
процедурам  практически  никакого отноше-
ния.
    Отличительной  особенностью процедуры
является  наличие  имени,  по  которому и
происходит ее вызов. Сейчас я приведу две
программы  иллюстрирующие  сказанное мной
выше,  первая  из  которых  написана  под
Spectrum бейсик, а вторая под ВВ:

I:

  10 LET PRIVET=100: LET I=0
  20 LET N=3: GO SUB PRIVET
  30 PRINT "I=";I,"N=";N
  40 STOP ""
 100 FOR I=1 TO N
 110 PRINT "HELLO!"
 120 NEXT I
 130 RETURN

 Результат:
HELLO!
HELLO!
HELLO!
I=4             N=3

II:

  10 LET I=7: LET N=18
  20 PRIVET 3
  30 PRINT "I=";I,"N=";N
  40 STOP
 100 DEF PROC PRIVET N
 110 LOCAL I
 120 FOR I=1 TO N
 130 PRINT "HELLO!"
 140 NEXT I
 150 END PROC

 Результат:
HELLO!
HELLO!
HELLO!
I=7             N=18

    Посмотрев на результаты начинаешь ис-
пытывать чувство сильного удивления: Ведь
I, как переменная цикла должна иметь зна-
чение  на  1  большее чем N, да и надпись
"HELLO!" должна была появиться по крайней
мере  18 раз, а не 3. Правда немного сму-
щают  строки  100  и 110, да еще какой то
бред  в 20 строке программы написанной на
ВВ.  Попробуем разобраться, сравнивая эти
два примера.
    Итак,  в  10 строке СБ (Спектрум бей-
сик) переменной PRIVET присваивается зна-
чение  100, т.е. номер строки подпрограм-
мы,  а  также  переменной I присваивается
значение  0. В этой же строке ВВ перемен-
ным  I  и N присваиваются значения 7 и 18
соответственно.
    В  20 строке СБ переменной N присваи-
вается  значение  3 и вызывается подпрог-
рамма,  находящаяся  в строке, адресуемой
переменной PRIVET. 20 строка ВВ представ-
ляет  для  нас очень большой интерес, так
как  на первый взгляд в ней нет ни одного
оператора. На самом же деле это не совсем
так,  потому что здесь просто опущен опе-
ратор PROC. Но тогда вы спросите: Как это
опущен?  Да,  в этом смысле СБ более кон-
сервативен и он не допускает таких вещей.
ВВ более гибок, поэтому понятие "по умол-
чанию"  встретится  нам  еще  не раз. Для
дальнейших объяснений нам придется перей-
ти сразу к 100 строке.
    Итак, 100 строка ВВ:
 100 DEF PROC PRIVET N
По  аналогии  с DEF FN можно сказать, что
DEF PROC есть определение процедуры, тог-
да PRIVET можно расценить как ее имя, а N
как  формальный  параметр.  Формальным он
называется  потому,  что как и в функциях
вне  процедуры  не  существует и поэтому,
вернувшись  к  20 строке ВВ мы видим, что
имеет  место вызов процедуры PRIVET с па-
раметром 3.
    Следующая  строка в ВВ тоже представ-
ляет некоторый интерес, так как в ней по-
падается  команда  LOCAL  и в связи с ней
надо  вспомнить еще одну особенность про-
цедур,  ради которой, собственно, и зате-
вался весь этот сыр-бор с примерами. Про-
цедура  является независимым блоком прог-
раммы за счет того, что она имеет так на-
зываемые  локальные переменные т.е. пере-
менные действующие только в пределах дан-
ной процедуры. Имена локальных и глобаль-
ных  (общих)  переменных могут совпадать,
но  изменения  локальных переменных никак
не отражаются на изменении глобальных пе-
ременных.  Таким образом, вам не надо все
время помнить какие переменные вы уже ис-
пользовали в программе.
    Возвращаясь к примерам можно сказать,
что  команда END PROC практически эквива-
лентна  команде RETURN, но это не значит,
что  можно произвольно менять их местами,
так как в ВВ понятие процедуры отличается
от понятия подпрограмма.
    Теперь,  объяснив  понятие  процедур,
перейдем  к их использованию, т.е. сейчас
я  попытаюсь  рассказать, как можно более
эффективно  использовать возможности ВВ в
этой области.
    Начнем  сначала,  т.е.  с параметров.
Правила ввода параметров в процедуру ана-
логичны правилам ввода параметров в функ-
ции  в  СБ,  за  исключением тех случаев,
когда  ввод  параметров оговорен отдельно
специальными командами ВВ. Первая из них:
REF a, или передача параметров по ссылке,
где а - имя переменной. Данный способ как
бы  переименовывает глобальную переменную
на время работы процедуры и позволяет по-
лучать  результат работы процедуры в гло-
бальной  переменной.  Приведу  пример  из
ZX-РЕВЮ N1 за 1992 год:

  10 LET X$="H1":
     LET Y$="GOODBYE"
  20 SWOP X$,Y$
      30 PRINT X$,Y$
 100 DEF PROC SWOP REF A$,
     REF B$
 110 LOCAL T$
 120 LET T$=A$: LET A$=B$:
       LET B$=T$
 130 END PROC

 Результат:
GOODBYE         H1

    Ссылка используется также для переда-
чи  в качестве параметра массива, так как
передача  массивов  в качестве параметров
непосредственно запрещена.
    Еще  одна команда, позволяющая упрос-
тить  работу с процедурами, выглядит так:
DEFAULT  a=. , где а - формальный пара-
метр.  Эта команда позволяет опускать па-
раметр  a при вызове процедуры, т.е. поз-
воляет устанавливать значение какого либо
параметра  "по  умолчанию". Так как, воз-
можно,  понять  это  может  быть довольно
сложно, то я опять обращусь к примерам:

  10 MULT 10,5
  20 MULT 10
  30 MULT ,5
  50 STOP
 100 DEF PROC A,B
 110 DEFAULT B=A: DEFAULT A=B
 120 PRINT A*B
 130 END PROC

Результат:
50
100
25
    В данном случае при отсутствии одного
параметра  ему по умолчанию присваивается
значение другого параметра.
    Ну  и  закончить рассказ о параметрах
можно  понятием  списка.  Для указания на
то,  что параметры передаются списком ис-
пользуется ключевое слово DATA.
    Что  же такое список параметров и за-
чем  он  нужен? Бывают ситуации в которых
мы  не  знаем заранее количества парамет-
ров,  в  этом случае и применяется список
параметров.   Использовать  параметры  из
этого  списка  не просто, а очень просто.
Но в начале как всегда пример:

  10 SUMMA 1,2,3
  20 SUMMA 3,4,5,6,9
  30 SUMMA 1
  40 STOP
   100 DEF PROC SUMMA DATA
 110 S=0
 120 IF ITEM()=0 THEN GO TO 160
 130 READ A
 140 S=S+A
 150 GO TO 120
 160 PRINT "SUMMA=";S
 170 END PROC

Результат:
SUMMA=6
SUMMA=27
SUMMA=1

    Здесь  использовалась функция ITEM(),
которая   определяет   следующий  элемент
списка, т.е. ITEM()=0, если список исчер-
пан;  ITEM()=1, если следующий параметр -
число; ITEM()=2,если следующий параметр -
строка.
    Оператор DATA в данном случае исполь-
зовался   для  извлечения  параметров  из
списка.
    В  использовании функций в ВВ никаких
значительных  изменений по сравнению с СБ
не  произошло, хотя количество встроенных
   функций значительно возросло.

      Условные операторы.

    В  СБ  имеется  лишь одна конструкция
условного оператора IF . THEN, В ВВ эта
конструкция была расширена оператором EL-
SE:

   IF условие THEN K1 ELSE K2
    Где K1 и K2 группы операторов. В слу-
чае  выполнения  условия  выполняется K1,
иначе K2 Оператор

GO TO ON a,n1,n2,n3,.
   GO SUB ON a,n1,n2,n3,.

спользуется для выбора номера строки пе-
рехода т.е. при а=1 переход на строку n1;
при а=2 на строку n2 и т.д.
 Вторая форма этого оператора:
 ON  a,k1,k2,k3,.  используется для вы-
полнения  операторов из списка. После вы-
полнения  оператора управление передается
на следующую строку.
    Кроме вышеперечисленных форм есть еще
одна специфическая форма:
 ON ERROR n
 ON ERROR: k1:k2:.
    Эта  команда  позволяет перехватывать
практически все сообщения об ошибке, кро-
ме:
 0: ОК.
 9: STOP statement.
    При  использовании  первой  формы при
ошибке происходит переход на строку n.
    Во втором случае выполняется последо-
вательность операторов k1, k2, .
      Отключается режим командой:
 ON ERROR 0
    При  обработке  ошибки могут быть по-
лезны три специальные переменные:
 LINO  - номер строки в которой
         произошла ошибка.
 STAT  - номер оператора в этой
         строке.
 ERROR - код ошибки.
    После  выполнения  оператора ON ERROR
перехват ошибки отключается, поэтому если
вы  хотите постоянно контролировать ошиб-
ки,  то не забудьте вставить восстановле-
ние режима после обработки ошибки.

            Циклы.

    Перед тем, как начать рассказывать об
использовании  циклов  в  ВВ мне придется
отклониться  и рассказать о видах циклов.
Те,  кто знает, что такое циклы с предус-
ловием и постусловием могут смело пропус-
тить следующие несколько абзацев.
    В  цикле с предусловием в начале про-
веряется  условие и, в зависимости от его
выполнения  тело  цикла либо выполняется,
либо  происходит  выход  из  цикла. На СБ
цикл  с  предусловием  можно  представить
так:

  10 LET I=1: LET N=10
     20 IF I>=N THEN GO TO 50
  30 PRINT I: LET I=I+1
  40 GO TO 20
  50 PRINT I: STOP

Результат:
1
2
3
4
5
6
7
8
9
10
    В случае, когда условие не выполняет-
ся сразу, тело цикла тоже не будет выпол-
нено.
    Цикл с постусловием всегда выполняет-
ся хотя бы раз.

  10 LET I=1: LET N=10
  20 PRINT I: LET I=I+1
    30 IF I<N THEN GO TO 20
  40 PRINT I: STOP

Результат:
1
2
3
4
5
6
7
8
9
10
    Как  вы видите результаты работу того
и  другого типов цикла одинаковы, однако,
если  условие  в  цикле с постусловием не
будет  выполнено сразу, то тело цикла все
равно будет выполнено хотя бы раз.
    В ВВ введена новая конструкция цикла:
  DO
  .
  LOOP
    При  встрече  команды  LOOP  ВВ  ищет
предшествующий  ей DO и передает управле-
ние  на оператор следующий за DO. При ис-
пользовании  только  операторов DO и LOOP
мы  получаем  так  называемый бесконечный
цикл.  Поэтому введены дополнительные ко-
манды:
      WHILE условие
      UNTIL условие
Эти  операторы  ставятся после операторов
DO  и  LOOP,  определяя условия выхода из
цикла.  Если  они  стоят после DO, то это
цикл  с предусловием, если после LOOP, то
это цикл с постусловием.
    WHILE указывает на то, что цикл будет
выполняться  до тех пор, пока условие вы-
полняется,  а  UNTIL  указывает, что цикл
выполняется  пока условие не будет выпол-
нено.
  Пример:

I.

  10 LET I=1: LET N=10
  20 DO
  30 PRINT I: LET I=I+1
  40 LOOP
  50 STOP

II.

  10 LET I=1: LET N=10
  20 DO WHILE I<N
  30 PRINT I: LET I=I+1
  40 LOOP
  50 STOP

I.

  10 LET I=1: LET N=10
  20 DO UNTIL I>=N
  30 PRINT I: LET I=I+1
  40 LOOP
  50 STOP

IV.

  10 LET I=1: LET N=10
  20 DO
  30 PRINT I: LET I=I+1
  40 LOOP WHILE I<N
  50 STOP

V.

  10 LET I=1: LET N=10
  20 DO
  30 PRINT I: LET I=I+1
  40 LOOP UNTIL I>=N
  50 STOP

    В отличии от цикла FOR . NEXT здесь
запрещено перекрывание циклов.
    Для  досрочного  выхода из цикла пре-
    дусмотрен оператор:
  EXIT IF условие
    При выполнении условия происходит пе-
реход на оператор следующий за LOOP.

_________________________________________





Из журнала ZX Format #7,
Санкт-Петербург, 06.12.1997



               Команды ББ.
               (Окончание)

(C)Д.Рудовский
_________________________________________

   В  этой статье я закончу описание ББ и
дам  несколько советов по его использова-
нию.
 ОС Спектрума имеет свои внутренние часы,
т.е. переменную, в которой хранится коли-
чество  пятидесятых долей секунды (преры-
ваний),  пришедших  с  момента  включения
компьютера. Создатели ББ решили использо-
вать  эту возможность для организации ча-
сов в программе.
 Команда CLOCK "строка" - позволяет уста-
новить  текущее значение времени, а также
установить  будильник.  Для установки бу-
дильника  первым символом в строке должен
быть символ A (alarm - будить.).
 Строка должна быть введена в виде:
 "чч:мм:сс",  для  будильника  секунды не
указываются.
 Для использования возможностей будильни-
ка дополнительно введен формат:
 CLOCK n, где:

  n=0 -  показания не выводить, будильник
       отключить;
  n=1 -   указывать время  в верхнем углу
       экрана, будильник отключить;
  n=2 -  время не показывать, выдать зву-
       ковой сигнал по будильнику;
  n=3 -   указывать время и выдавать зву-
       ковой сигнал по будильнику;
  n=4 -  не указывать время, при срабаты-
       вании будильника перейти на стро-
       ку;
  n=5 -  аналогично n=4 с выводом времени
       на экран;
  n=6 -   аналогично n=4 с выдачей звуко-
       вого сигнала перед переходом;
  n=7 -  n=5 и n=6 вместе;
  n=8..9999 -   установить номер строки,
       на которую будет произведен пере-
       ход при срабатывании будильника.

 Пример:
  10 PRINT " 346*789=? "
  20 CLOCK "00:00:00": CLOCK "A00:01"
  30 CLOCK 1000: CLOCK 7
  40 INPUT X
  50 IF X=346*789 THEN PRINT
     "Very Good!" ELSE "Bad rezult!":
  GO TO 40
  60 CLOCK 0
  70 STOP
1000 CLOCK 0
1010 PRINT "No more time!"
1020 STOP

 Пояснения:
 В  20  строке мы устанавливаем системные
часы в 0, а будильник ставим на 1 минуту.
 В  30 строке мы устанавливаем строку пе-
рехода и режим работы часов ( см. выше).
 Затем  мы  запрашиваем ввод числа и если
результат  верен, и прошло меньше минуты,
то  мы  получим надпись "Very Good", часы
будут  поставлены в пассивное состояние (
строка 60) и программа остановится.
 Если  результат  неверен,  но  время еще
есть, то с выводом соответствующего сооб-
щения произойдет переход обратно на стро-
ку 40.
 Если  время  истечет, то вне зависимости
от результата будет выдан звуковой сигнал
и произойдет переход на строку 1000.
 ВНИМАНИЕ!!! Переход по будильнику проис-
ходит только после выполнения всей! теку-
щей  строки. Также этот режим не работает
во время редактирования текста.

 Команда SORT используется для сортировки
массивов и символьных строк. Ее формат:
  SORT [INVERSE] var, где:

 INVERSE -  необязательный параметр, ука-
          зывающий  на условие сортиров-
          ки,  т.е. при его наличии сор-
          тировка  будет  происходить по
          убыванию  значений,  иначе, по
          возрастанию;
   var   - имя массива или строки.
 Сортировка   происходит  для  символьных
массивов  по первой символу по умолчанию.
Для сортировки по другому символу исполь-
зуется конструкция: SORT S$() (N TO),где:

 S$ - символьный массив;
  N - номер  символа  по которому будет
      произведена сортировка.
 Для сортировки части массива используют:
  SORT S$(N TO M) , где:
 N,M - границы сортировки.

Пример:
   10 DIM a$(100,10)
   20 FOR I=1 TO 100
   30 FOR J=1 TO 10
   40 LET A$(I,J)= CHR$(RND*25+65)
   50 NEXT J: PRINT A$(I)
   60 NEXT I
   70 PRINT "Sorting for 1st char:"
   80 SORT A$
   90 FOR I=1 TO 100
  100 PRINT A$(I)
  110 NEXT I
  120 PRINT "Sorting for 2st char:"
  130 SORT A$()(2 TO)
  140 FOR I=1 TO 100
  150 PRINT A$(I)
  160 NEXT I
  170 STOP

 На  этом  я  закончу описание команд ББ,
приведя  в  конце справку по соответствию
клавиш и команд (все команды набираются в
режиме псевдографики):

 [A] - ALTER          [6] - AUTO
 [C] - CLOCK          [1] - DEF KEY
 [1] - DEF PROC       [7] - DELETE
 [D] - DO             [P] - DPOKE
 [0] - EDIT           [E] - ELSE
 [3] - END PROC       [I] - EXIT IF
 [F] - FILL           [G] - GET
 [CS]+[6] - JOIN      [CS]+[6] - KEYIN
 [8] - KEYWORDS 0     [9] - KEYWORDS 1
 [L] - LOOP           [O] - ON
 [N] - ON ERROR       [Q] - POP
 [2] - PROC           [9] - RENUM
 [R] - ROLL           [S] - SCROLL
 [M] - SORT           [T] - TRACE
 [P] - USING

              Функции ББ.

 Кроме дополнительных команд ББ предлага-
ет  несколько новых функций, которые вво-
дятся  также, как и обычные, определяемые
пользователем,  но воспринимаются ББ, как
внутренние.
 Все  функции  можно условно разделить на
три  группы: логические, математические и
остальные.

    К логическим функциям относятся:

 AND(n,m) [FN A(] - логическое И;
  OR(n,m) [FN O(] - логическое ИЛИ;
 XOR(n,m) [FN X(] - исключающее ИЛИ.

  К математическим функциям относятся:

 а) Функции преобразования форматов:
 BIN$(n) [FN B&(] -  преобразование деся-
                   тичного  числа в дво-
                   ичную строку;
 DEC(строка) [FN  D(]  -   преобразование
                   строки,    содержащей
                   шестнадцатиричное чис-
                   ло, в десятичное.
 HEX$(n) [FN H(] -  преобразование  деся-
                   тичного    числа    в
                   шестнадцатиричную
                   строку;
 USING$(формат, число) [FN U$(] -  знако-
                   вая   запись  числа  в
                   заданном формате.

 б) расширенные стандартные функции:
 COSE(n) [FN C(] -  более быстрый и более
                   грубый вариант cos;
 SINE(n) [FN S(] -  аналог. для sin;
 DPEEK(n) [FN P(] -  аналогично:
                  256*PEEK(N+1)+PEEK(N);
 RNDM(n) [FN R(] -  аналогично:
                   n*RND.

 К  остальным  функциям относятся функции
определения  объема  памяти,  содержимого
экрана и т.д.

 CHAR$(n) [FN C$(] -  преобразование чис-
                   ла  в пределах 0-65535
                   в  эквивалентную стро-
                   ку из двух знаков;
 FILLED() [FN F(] -  количество элементов
                   изображения,    запол-
                   ненных  последней  ко-
                   мандой FILL;
 INSTRING(n,стр1,стр2)  [FN I(] - возвра-
                   щает  позицию  первого
                   знака  строки   2  при
                   просмотре   строки  1,
                   начиная   с   заданной
                   стартовой     позиции.
                   Если  внутри  строки 1
                   нет   строки   2, то
                   возвращает 0.
 MEM()  [FN  M(] -  возвращает объем сво-
                   бодной памяти;
 MEMORY$()  [FN M$(] -  возвращает значе-
                   ние   всей памяти от 0
                   до  65535  интерпрети-
                   рованное ,  как   одна
                   строка;
 MOD(n1,n2) [FN V(] -  возвращает остаток
                   деления n1 на n2;
 NUMBER(строка) [FN N(] -  преобразование
                   строки из  двух знаков
                   в  двухбайтовое число,
                   где  каждый  байт  со-
                   держит  число, отвеча-
                   ющее  заданному   коду
                   ASCII;
 SCRN$(y,x)  [FN K$(] -  возвращает знак,
                    находящийся на экране
                    в  заданной  позиции;
 STRING$(n,строка)  [FN S$(] -  повторяет
                    строку заданное коли-
                    чество раз;
 TIME$()  [FN  T$(] -  возвращает строку,
                    содержащую    текущее
                    время.

      Особенности программирвания
                 в ББ.

 Расширяя возможности стандартного бейси-
ка,  ББ изменяет и сами методы программи-
рования,  поэтому  при  работе в среде ББ
желательно учитывать следующие моменты:
  1) В результате изменения действия опе-
ратора FOR...NEXT скорость его выполнения
значительно возрастает при работе с целы-
ми числами в интервале 0..65535, следова-
тельно  старайтесь обходиться целочислен-
ными циклами.
  2)  В  результате  появления процедур и
связанных с ними локальных переменных по-
явилась  возможность  существенно сэконо-
мить  память за счет локализации перемен-
ных.  Также  это  позволяет вам перейти к
понятию структуризации программы.
  3) Наличие возможности форматированного
вывода  и  введение  оконного  интерфейса
позволяет  упорядочить вывод на экран не-
обходимой информации.
  4)  Команда  сортировки позволяет более
эффективно  использовать ББ при организа-
ции баз данных.

_________________________________________