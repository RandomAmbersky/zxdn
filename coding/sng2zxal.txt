Из журнала Scenergy #2, Новгород, 2000



(C) Flying/DR


               ZXA library


              0. Вступление

 Как  вы, наверняка уже догадались - здесь
я буду рассказывать вам о том что же такое
ZXA  library  и как вы можете использовать
ее в своих программах.

 Однако  для  начала, если вы еще этого не
сделали   -  я  настоятельно  советую  вам
прочитать статью "Упаковка анимаций в JAM"
для  того чтобы  понимать, о чем конкретно
пойдет разговор дальше. Кроме того было бы
очень  хорошо,  если  бы  вы также заранее
прочитали  статью "О библиотеках". Если же
вы все это уже сделали - читайте дальше.

            1. Общие сведения

 Итак,  что  же  такое  ZXA  library.  Это
свободно   распространяемая  в  исходниках
библиотека, предназначенная для создания и
проигрывания  анимаций. Библиотека состоит
из 2 частей:
 1) Упаковщик и вьюер анимаций.  Эта часть
библиотеки написана на Borland Pascal v7.0
на PC.
 2) Плееры анимаций. Эта часть написана на
Speccy в TASM v4.12 by RST7/CBS.
 Т.о.  для  того чтобы использовать данную
библиотеку  вам,  к сожалению, обязательно
придется   иметь  доступ  к  PC  (или  его
эмулятору).  Однако  если подумать, то это
не  такое  уж  невыполнимое  условие - все
равно  анимации, как правило, создаются не
на Speccy,  а на более мощных машинах. Для
работы  упаковщика и вьюера анимаций будет
достаточно  любого  PC, начиная с 386-го с
1mb  памяти и 256кб VGA видеокартой. Кроме
того, пойдет и любой эмулятор PC для Amiga
или Apple Macintosh.
 Кроме  того, для  того чтобы использовать
ZXA library вам придется работать в TASM'е
или  же  попытаться  портировать  ее в тот
ассемблер,  в  котором вы работаете. Здесь
дело  в том, что ZXA library написана так,
как, по-моему, должна  быть написана любая
хорошая   библиотека   -  она  может  быть
полностью   переконфигурирована  для  нужд
конкретного пользователя без вмешательства
в ее код. Естественно, что все это сделано
за  счет макросов и условной компиляции, а
это на данный момент поддерживают в полной
мере  только два ассемблера: TASM v4.12 by
RST7/CBS и ALASM v4.2 by Alem (modified by
KVA/E-Mage). В принципе ZXA library вполне
может  быть  перенесена в ALASM v4.2 почти
не   потеряв  своей  гибкости  (все  будет
работать  за исключением одной вещи, но об
этом  ниже). Однако я не стал этого делать
из-за нехватки времени, а также из-за того
что  существующий  конвертор  в  ALASM  не
поддерживает расширения синтаксиса ALASM'а
версии 4.2.

 Несмотря на то, что библиотека состоит из
2  частей  -  здесь будет подробно описана
только  та  часть,  что  касается  Speccy.
Описание  упаковщика и вьюера анимаций для
PC  вы  найдете  в приложении, в архивах с
программами и исходниками для PC.

 Все   компоненты  библиотеки  помещены  в
приложение и представляют собой 4 архива:

ZXApcEXE.ZIP - Откомпилированные и готовые
 к использованию файлы упаковщика и вьюера
 анимаций.  Будут  полезны для тех, кто не
 хочет разбираться с работой упаковщика, а
 хочет  просто  использовать его для своих
 нужд.
ZXApcSRC.ZIP - Исходные тексты  упаковщика
 и вьюера анимаций для PC. Необходимы тем,
 кто  захочет  разобраться  в их работе и,
 возможно, использовать для своих целей.
ZXAanims.ZIP - Несколько примеров анимаций
 для демонстрации работы библиотеки. Могут
 быть  использованы  как для PC, так и для
 Speccy.
ZXA_src .ZIP - Исходники самой ZXA library
 и нескольких примеров для демонстрации ее
 возможностей.

ZXApcEXE.ZIP   и   ZXApcSRC.ZIP  упакованы
PKZIP'ом на PC, ZXAanims.ZIP и ZXA_src.ZIP
упакованы ZxZip'ом.

        2. Возможности библиотеки

 ZXA  library  предоставляет  пользователю
следующий набор функций:
 - Проигрывание анимаций в 3 режимах:
   - Обычные анимации
   - Interlaced анимации
   - C64 like анимации
 - Любой  из  перечисленных  выше  плееров
   может  работать  как  с  одним, так и с
   двумя   экранами.  В  последнем  случае
   возможна   также  автоматическая  смена
   видимого экрана после вывода очередного
   кадра.  При  выводе  анимации  на  один
   экран можно выбирать - на какой именно.
 - Любой тип анимаций  может быть проигран
   в любой последовательности кадров.
 - Анимации  можно  размещать в страничной
   памяти (даже если анимация выводится на
   два экрана).
 - Есть режим при котором все используемые
   таблицы  и  процедуры  располагаются  в
   нижней  памяти  (#6000-#7FFF)  для того
   чтобы   освободить   больше  места  под
   размещение анимации.
 - Анимация может быть  разделена в памяти
   на  несколько  частей,  эти  части даже
   могут  располагаться в разных страницах
   памяти!
 - Размер проигрываемой анимации ограничен
   256 кадрами.
 - Размер кадра анимации  для Interlaced и
   C64 like плееров  может быть любым, для
   нормального плеера, при выводе анимации
   с использованием  обоих экранов  размер
   кадра  в  распакованном состоянии может
   быть  не более #1280 байт (это примерно
   24x24 или 32x18 знакомест).
 - Все плееры  используют стек для доступа
   к   данным,   однако  есть  возможность
   использовать специальный обработчик IM2
   для предотвращения порчи информации при
   приходе  прерывания.  Т.о.  все  плееры
   можно  использовать  при включенных IM2
   прерываниях.
 - Вся  настройка   параметров  библиотеки
   осуществляется   через  переопределение
   конфигурационных переменных БЕЗ какого-
   либо вмешательства в код библиотеки!
 - В случае некорректного задания значений
   параметров конфигурации, при компиляции
   будет  выдано соответствующее сообщение
   и даны рекомендации  по его устранению.
   Кстати, именно это невозможно сделать в
   ALASM'е.
 - Тексты  всех  модулей библиотеки хорошо
   комментированы и имеют краткое описание
   особенностей работы с каждым из них.
 - Вместе с кодом модулей  библиотеки идет
   несколько  примеров  их  использования.
   Посмотрев  на  них  можно  увидеть, что
   количество   кода,   необходимого   для
   проигрывания   анимации   составляет  в
   среднем всего 20-30 строк.
 - Время  распаковки  кадра  для  тестовых
   анимаций  на Pentagon'е составляет чуть
   более прерывания.

 ZXA library состоит из следующих модулей:
MEMORY.A   - Макробиблиотека,  реализующая

механизм распределения памяти

в программе.
ZXA_EQUS.A - Этот файл содержит в себе все

конфигурационные  переменные,

необходимые  для всех модулей

ZXA library.
ZXA_1.A    - Плеер  обычных  и  interlaced

анимаций на одном экране.
ZXA_2.A    - Плеер  обычных  и  interlaced

анимаций на двух экранах.
  - Плеер C64 like анимаций.
ZXA_CODE.A - Набор дополнительных процедур

необходимых для плееров.
EXAMPLE1.A - Пример  проигрывания  обычной

или interlaced анимации.
EXAMPLE2.A - Пример проигрывания  C64 like

анимации.
EXAMPLE3.A - Пример проигрывания анимации,

состоящей из двух кусков.

       3. Использование библиотеки.

 Для того чтобы использовать ZXA library в
своих программах вам необходимо:
 - Создать и подгрузить ZXA анимацию.
 - Подключить к своему коду файлы:
   - MEMORY.A  и  ZXA_EQUS.A.   Эти  файлы
     обеспечат создание всего необходимого
     для нормальной настройки и компиляции
     всех модулей ZXA library.
   - Один из плееров: ZXA_1.A, ZXA_2.A или
     ZXA_C64.A.  Какой  именно плеер нужно
     подключить - зависит  от того,  каким
     способом была упакована анимация.
   - ZXA_CODE.A для  создания  необходимых
     для работы плееров процедур.
 - Сконфигурировать  код  плееров  под то,
   как  именно они должны работать в вашей
   программе.
 - Написать кусок кода для инициализации и
   проигрывания анимации.
 - При  необходимости  добавить  к  своему
обработчику  прерываний  код для коррекции
данных  на  стеке, испорченных при приходе
прерывания.

 Пример кода для проигрывания анимации:

;Подключаем файлы с необходимыми описаниями
        .INCLUDE MEMORY
        .INCLUDE ZXA_EQUS

        ORG #8000
;Инициализируем код плеера
        LD HL,ANIMATION    ;В HL - указатель на анимацию
        CALL ZXA_INIT
;Включаем режим прерываний IM2
        DI
        LD HL,#BE00
        LD DE,#BE01
        LD BC,#100
        LD (HL),#BF
        LDIR
        LD A,#C3           ;JP nnnnn
        LD (#BFBF),A
        LD HL,IM2          ;Указатель на обработчик прерываний
        LD (#BFC0),HL
        LD A,#BE
        LD I,A
        IM 2
        EI
;Переменная ZXA_QFRAMES содержит количество кадров
;в анимации
        LD A,(ZXA_QFRAMES)
        LD B,A
        LD C,0
LOOP    PUSH BC
        HALT
;На входе в процедуру рисования кадра анимации ZXA_DRAW_FRAME
;в регистре A необходимо передавать номер кадра анимации
;который необходимо отрисовать.
        LD A,C
        CALL ZXA_DRAW_FRAME
;Переходим к следующему кадру
        POP BC
        INC C
        DJNZ LOOP
 
;Вся анимация проиграна - выходим
        DI
        LD A,#3F
        LD I,A
        IM 1
        EI
        RET

;Подключаем код плеера и дополнительный код
        .INCLUDE ZXA_1
        .INCLUDE ZXA_CODE

;Обработчик IM2 прерываний
;Здесь есть одна тонкость. Дело в том, что обработчик
;ДОЛЖЕН быть расположен ПОСЛЕ того как будет подключен
;код плеера. Это обусловлено тем, что код восстановления
;данных запорченных стеком реализован в виде макросов и
;необходимо сделать так, чтобы на момент компиляции
;обработчика прерываний эти макросы были определены.
;Опасность ошибки заключается в том, что если они не были
;определены - их вызов будет восприниматься компилятором
;как определение метки, все будет откомпилировано без
;ошибок, а в результате мы получим нерабочий код.
IM2
;Вызов макроса, создающего код для восстановления данных
        _ZXA_IM2_START
;Здесь может располагаться все что необходимо сделать в
;обработчике прерываний.
;Вызов макроса, создающего код для восстановления данных
        _ZXA_IM2_END
;Подгружаем анимацию
ANIMATION
        .INCBIN anim

 Вот  и  все,  что необходимо сделать. Как
видите  -  все  элементарно. Правда, как и
везде,  здесь есть свои тонкости, но о них
позже.  Сейчас  необходимо  рассказать  об
общих принципах работы библиотеки и о том,
как настроить ее под ваши нужды.

            4. Принципы работы

 Библиотека  проигрывает  ZXA  анимации во
всех  форматах поддерживаемых упаковщиком,
но  с двумя ограничениями. Можно проиграть
только анимации упакованные:
 - с вертикальным кодированием кадра.
 - с независимо упакованными кадрами.
 В  принципе, упаковщик поддерживает и все
остальные методы упаковки (ключи /a и /h),
но  фактически на данный момент эти методы
не  имеют  практического значения (их даже
не поддерживает viewer на PC).
 В  принципе,  никаких особенных проблем с
тем  чтобы  сделать  поддержку  анимаций с
горизонтальным  кодированием  кадров  нет,
однако,  как  я  уже  говорил  в статье об
упаковке  анимаций  -  качество упаковки в
этом режиме значительно ниже.

 Поскольку  все  кадры  анимации упакованы
независимо  -  их  можно  распаковывать  в
любой  последовательности.  Поэтому  в ZXA
library  отсутствует  функция проигрывания
анимации, а есть только функция распаковки
кадра  по  его  номеру.  Так что для того,
чтобы  проиграть  анимацию  вам необходимо
самим  написать основной цикл проигрывания
анимации  (как  уже  было  показано выше в
примере).

 Перед  тем  как  проиграть  анимацию - ее
необходимо  зарегистрировать. Это делается
путем  вызова функции ZXA_INIT с передачей
в  HL указателя на анимацию. Если анимация
состоит  из  нескольких  фрагментов  -  их
можно  объединить  в одну большую анимацию
путем  вызова  функции  ZXA_ADD_FRAMES для
каждого из фрагментов. При этом в HL нужно
передавать   указатель   на   подключаемую
анимацию,  а  в A - номер кадра, начиная с
которого  эта  анимация  будет  вставлена.
Количество фрагментов не ограничено, а вот
общее количество кадров во всех фрагментах
ограничено 256. Общее количество  кадров в
анимации всегда можно узнать из переменной
ZXA_QFRAMES. Так что обычный фрагмент кода
для  подключения  фрагмента анимации будет
выглядеть так:

        LD HL,ANIMATION_PART
        LD A,(ZXA_QFRAMES)
        CALL ZXA_ADD_FRAMES

 Отличие  между функциями ZXA_ADD_FRAMES и
ZXA_INIT состоит в том, что ZXA_INIT кроме
всего   прочего  создает  все  необходимые
таблицы  и  процедуры,  так  что  ее нужно
вызывать  ДО  того как будет вызвана любая
другая  функция библиотеки. Также ее нужно
вызывать,  если  после  проигрывания одной
анимации вы хотите проиграть другую.

 Все плееры, входящие в состав ZXA library
требуют  для  свой  работы наличие таблицы
экранных  адресов.  Эта таблица содержит в
себе  адреса  всех  байт  экрана в которые
попадает кадр анимации, и используется для
отрисовки  кадра на экране. Размер таблицы
равен  удвоенному  размеру  распакованного
кадра,  например,  для размера кадра 10x16
знакомест размер таблицы будет равен:
           10*16*8*2=2560 байт

 Поскольку  плеерам,  по  сути,  все равно
какие  именно адреса указаны в таблице, то
можно  использовать  это  для  того  чтобы
распаковывать  анимацию  не  на экран, а в
любой  буфер.  Достаточно просто заполнить
таблицу   адресами   этого  буфера.  Также
простым  переделыванием этой таблицы можно
получить плеер для проигрывания анимаций с
горизонтальной кодировкой кадра.
 Таблица  экранных  адресов  по  умолчанию
располагается в 7 странице с адреса #DB00,
сразу  после  второго  экрана.  Однако  ее
можно  свободно переместить в любое другое
место,  где  достаточно  свободной памяти.
Единственное исключение: при использовании
любого   из   плееров   для  двух  экранов
необходимо чтобы таблица располагалась в 7
странице  (чтобы  она  была  доступна  при
отрисовке  кадра на второй экран). Кстати,
именно  из-за  этого данный плеер не может
проигрывать   анимации  с  размером  кадра
более #1280 байт, просто не хватает памяти
под размещение таблицы экранных адресов.
 Местоположение  таблицы в памяти задается
двумя конфигурационными переменными:

ZXA_TABLE_PAGE - номер страницы
ZXA_TABLE_ADR  - адрес размещения таблицы

 Кроме  таблицы  экранных  адресов плеерам
необходима  память под различные таблицы и
процедуры.   Размер   необходимой   памяти
зависит от конкретной конфигурации, но как
минимум будет занято чуть более килобайта.
Плеерам анимаций на одном экране требуется
меньше  всего памяти, да и сами они меньше
чем аналогичные двухэкранные. Больше всего
памяти  требуется плееру C64 like анимаций
т.к. в этом  случае  распаковка кадра идет
не на экран, а в буфер, а затем этот буфер
отрисовывается   на  экране.  Из-за  этого
проигрывание  C64  like  анимаций работает
немного  медленнее обычных, но это отчасти
компенсируется  тем,  что  реальный размер
кадра  в  этом  режиме в 4 раза меньше чем
видимый на экране.
 По  умолчанию  все  таблицы размещаются в
"медленной"  памяти  (#6000-#7FFF),  а все
процедуры - в "быстрой"  (#8000-#BFFF). Но
в целях экономии так нужной всем "быстрой"
памяти ZXA library имеет специальный режим
при  котором  все  - и таблицы и процедуры
размещаются  в "медленной" памяти оставляя
больше  места  для  нужд  программы.  Этот
режим включается опцией:
           ZXA_ALL_IN_SLOW=YES

         5. Настройка параметров

 Как  уже  было  сказано выше - вся работа
ZXA  library  может  контролироваться  БЕЗ
какого-либо  вмешательства  в  код модулей
библиотеки.  Все что вам нужно сделать для
конфигурирования  кода библиотеки под ваши
нужды - изменить значения конфигурационных
переменных,  отвечающих за настройку кода.
Причем  для этого  тоже  не нужно  лезть в
код - вся настройка осуществляется простым
переприсваиванием значений переменных.
 Все переменные описаны в файле ZXA_EQUS.A
и  менять  их  значения можно только ПОСЛЕ
того  как  этот  файл  подключен  к вашему
исходнику,  но ДО того как будет подключен
любой  модуль  библиотеки  содержащий код.
Кроме   ZXA_EQUS.A  необходимо  подключить
также  файл MEMORY.A. Это макробиблиотека,
отвечающая за распределение памяти во всех
модулях  библиотеки.  Оба  этих  файла  не
содержат  ни строчки кода - только макросы
и определения переменных. Т.о. их можно, и
даже  нужно,  подключать  в  самом  начале
вашего  исходника,  а  все переопределения
конфигурационных  переменных  лучше  всего
располагать  сразу  после  подгрузки  этих
модулей.  Вот  как, примерно, должен будет
выглядеть ваш исходник:

;Подгрузка модулей с необходимыми описаниями.
;Заметьте, что порядок их подгрузки должен быть именно таким!
        .INCLUDE MEMORY
        .INCLUDE ZXA_EQUS
;Все необходимые переопределения параметров библиотеки
ZXA_USE_FRAME_BUFFER=YES
ZXA_FRAME_BUFFER_SIZE=450

 Подобная последовательность действий даст
компилятору  возможность сгенерировать код
в  соответствии  с вашими настройками т.к.
все  значения  переменных будут изменены к
моменту  начала компиляции кодовых модулей
библиотеки.

 А теперь непосредственно то, о чем должна
идти речь в этом разделе.

Переменная  : ZXA_USE_FRAME_BUFFER
По умолчанию: NO
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: Отвечает за выделение в нижней
памяти  буфера  для  текущего упакованного
кадра.  Если установить ее значение в YES,
то  в  памяти  дополнительно будет выделен
буфер  и  перед  началом распаковки любого
кадра упакованные данные будут скопированы
в  него,  а затем будут распаковываться из
буфера.  Создание  этого буфера необходимо
при проигрывании анимации на двух экранах,
а  также,  если  анимация  располагается в
страничной памяти.

Переменная  : ZXA_FRAME_BUFFER_SIZE
По умолчанию: 0
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: Задает  размер  буфера  кадра.
Значение  этой  переменной  не должно быть
меньше  максимального размера упакованного
кадра  анимации,  но и не нужно его делать
слишком  большим  (лишняя  трата  памяти и
времени т.к. в буфер  перебрасывается блок
данных  размером ZXA_FRAME_BUFFER_SIZE). В
случае  если  размер  буфера будет слишком
мал - последствия могут быть фатальные.

Переменная  : ZXA_INTERLACED
По умолчанию: NO
Влияет на   : ZXA_1, ZXA_2
Назначение: Определяет  тип  анимации  для
плееров ZXA_1.A или ZXA_2.A. Установите ее
значение  в YES, если необходимо проиграть
чересстрочную анимацию. Для плеера ZXA_C64
эта переменная не нужна.

Переменная  : ZXA_ALL_IN_SLOW
По умолчанию: NO
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: Если значение  этой переменной
установлено в YES - таблицы  и  процедуры,
создаваемые любым плеером  будут размещены
в медленной памяти (#6000-#7FFF). Если NO,
то  таблицы  будут размещаться в медленной
памяти, а процедуры - в быстрой.

Переменная  : ZXA_LARGE_ANIMATION
По умолчанию: NO
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: При  необходимости   проиграть
анимацию, состоящую  из нескольких частей,
расположенных  в разных  страницах памяти,
нужно установить  значение этой переменной
в YES. При этом изменится набор параметров
для  функций  ZXA_INIT и ZXA_ADD_FRAME: на
входе,  кроме  всего  прочего,  необходимо
будет  передавать  в  регистре  C страницу
памяти, в которой расположена анимация или
ее часть. Т.е. формат вызова будет таким:

Для ZXA_INIT:        Для ZXA_ADD_FRAME:

LD HL,ANIMATION      LD HL,ANIMATION_PART
LD C,ANIMATION_PAGE  LD C,ANIMATION_PART_PAGE
CALL ZXA_INIT        LD A,(ZXA_QFRAMES)
                     CALL ZXA_ADD_FRAMES

Переменная  : ZXA_AUTO_FLIP_SCREEN
По умолчанию: YES
Влияет на   : ZXA_2, ZXA_C64
Назначение: В  случае  если  значение этой
переменной  равно  YES,  после  распаковки
очередного кадра анимации будет переключен
видимый  экран  (после HALT'а естественно)
для  того  чтобы  отобразить результаты на
мониторе.  Это  удобно  т.к.  позволяет не
заботиться  о переключении видимых экранов
самому.  Однако,  если  это  по каким-либо
причинам  нежелательно  - можно установить
значение этой переменной в NO. Нужно также
помнить,  что  эта  переменная имеет смысл
только  для  плееров анимаций использующих
два экрана.

Переменная  : ZXA_TABLE_PAGE
По умолчанию: #17
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: Номер страницы в которой будет
создана таблица экранных адресов. Помните,
что  при  использовании  плееров  для двух
экранов   необходимо,  чтобы  таблица была
расположена в странице #17!

Переменная  : ZXA_TABLE_ADR
По умолчанию: #DB00
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: Адрес,  по  которому  в памяти
будет   располагаться   таблица   экранных
адресов.  По  умолчанию  таблица находится
непосредственно после второго экрана.

Переменная  : ZXA_USE_SECOND_SCREEN
По умолчанию: NO
Влияет на   : ZXA_1, ZXA_C64
Назначение: По умолчанию  плееры  анимаций
для  одного  экрана  используют для вывода
первый  экран  (с  адреса  #4000). Если же
установить значение этой переменной в YES,
то  вывод  будет  осуществляться на второй
экран (с адреса #C000 в страницу #17).

Переменная  : ZXA_FRAME_XS
По умолчанию: 0
Влияет на   : ZXA_C64
Назначение: Размер  кадра  анимации  по X.
Задается в знакоместах. Возможные значения
лежат в промежутке 1..16.

Переменная  : ZXA_FRAME_YS
По умолчанию: 0
Влияет на   : ZXA_C64
Назначение: Размер  кадра  анимации  по Y.
Задается  в пикселях.  Возможные  значения
лежат  в  промежутке  1..96. Значения этих
двух переменных необходимо задавать только
при  использовании ZXA_C64 плеера т.к. его
код  необходимо  подстраивать  под  размер
кадра анимации.

Переменная  : ZXA_C64_USE_BOTH_SCREENS
По умолчанию: NO
Влияет на   : ZXA_C64
Назначение: Если нужно  проиграть C64 like
анимацию  на двух экранах - установите эту
переменную в YES.

Переменная  : ZXA_CREATE_IM2_TABLE
По умолчанию: YES
Влияет на   : ZXA_1, ZXA_2, ZXA_C64
Назначение: Отвечает   за   автоматическую
генерацию  таблицы IM2 прерываний, а также
стека  для  обработчика IM2 прерывания. По
умолчанию  и  таблица  и  место  под  стек
создаются  в памяти автоматически, но если
в   вашей   программе  таблица  прерываний
должна  быть  расположена  по  конкретному
адресу  -  вы  можете  отключить генерацию
таблицы   прерываний,  установив  значение
этой переменной в NO. Однако в этом случае
вам  придется  вручную  выделить место под
стек  обработчика  прерываний  (ему  нужно
где-то 30-40 байт) и занести его указатель
в переменную ZXA_IM2_STACK:

            LD HL,MY_IM2_STACK
            LD (ZXA_IM2_STACK),HL

               6. Замечания

 В  принципе всего написанного выше вполне
хватит  для полноценного использования ZXA
library  в  ваших  программах. Но есть ряд
тонкостей в использовании этой библиотеки,
о  которых  я  не  сказал ранее. О них я и
попытаюсь рассказать в этом разделе.

               6.1 Память

 ZXA  library  написана  с  использованием
моей макробиблиотеки - менеджера памяти. О
ней  вы можете подробно прочитать в статье
Memory Management Library.
 С одной стороны это  позволяет освободить
пользователя   от   необходимости  вручную
выделять память необходимую для библиотеки
(а это достаточно непростое дело, учитывая
обилие  настроек  влияющих на количество и
размеры  выделяемых  блоков памяти). Здесь
же  весь  механизм  распределения памяти с
точки  зрения  пользователя  прозрачен  и,
кроме   того,  программа  застрахована  от
ошибок при распределении памяти.
 Однако  с  другой стороны это накладывает
некоторые  ограничения  на саму программу,
использующую эту библиотеку. Проще говоря,
все распределение памяти в вашей программе
тоже  должно  происходить только через мою
макробиблиотеку!  В  принципе,  это должно
быть  очевидным - все распределение памяти
в  программе  должно  быть  реализовано по
одному  принципу, в противном случае можно
получить  просто кучу глюков. Да и то, что
вам  придется  использовать  мой  менеджер
памяти в своей программе, я считаю большим
достоинством,  а  не  недостатком.  Дело в
том,  что  при  его  использовании процесс
распределения  памяти  в  программе  очень
сильно  облегчается  и  становится намного
более наглядным. Кроме того менеджер будет
сам  следить  за  переполнением  памяти  и
сообщать об этом на этапе компиляции, т.е.
вам,  в  случае  чего,  не придется искать
причину  глюков  в  вашей  программе из-за
того,  что  две  таблицы  перекрывают друг
друга.
 Как  вы  наверняка понимаете, в менеджере
заложена  определенная схема распределения
памяти.   И  из  этого  следует  очевидный
вывод: ваша программа должна учитывать эту
схему  распределения. Т.е. все блоки вашей
программы:   код,  память  выделяемая  под
таблицы  и процедуры, таблица прерываний и
т.п.   должны  располагаться  в  памяти  в
соответствии  с  тем,  как  это заложено в
менеджере  памяти. Спасти вас может только
то, что версия 2.0 моего менеджера памяти,
которая  и использована в этой библиотеке,
может  быть  полностью переконфигурирована
под  любую схему распределения памяти. Так
что,  в  случае, если схема распределения,
установленная в менеджере по умолчанию вам
не подходит - смело переконфигурируйте его
и  весь код библиотеки будет автоматически
подстоен  под  новую  схему  распределения
памяти.
 Кроме  того, не забудьте, что стандартная
схема  распределения памяти подразумевает,
что  свободная  память  у вас начинается с
адреса #6000, т.е. стек расположен с #5FFF
или  еще  ниже. А в стандартном загрузчике
TASM'а стек установлен на адрес #61A7, так
что  у  вас  есть  выбор: либо поправить в
загрузчике  TASM'а  CLEAR  VAL  "24999" на
CLEAR  VAL  "24575",  либо добавить в вашу
программу строку:
         SET_SLOW #61A8,#8000,NO
сразу после .INCLUDE MEMORY
 Я советую использовать первый вариант.

              6.2 Переменные

 В любом плеере ZXA library есть несколько
переменных, которые могут вам понадобиться
для  собственных  нужд.  Здесь  я  приведу
краткие описания для каждой из них:

ZXA_IM2_STACK. В эту переменную вы обязаны
занести   указатель   на  область  памяти,
которая  будет использоваться обработчиком
IM2  прерываний под стек. Это нужно делать
только  в  случае если вы установили опцию
ZXA_CREATE_IM2_TABLE=NO и к тому же хотите
использовать   макросы   _ZXA_IM2_START  и
_ZXA_IM2_END  для  восстановления  данных,
испорченных приходом прерывания.
 Размер  области памяти используемой этими
макросами  составляет  примерно  24 байта,
добавьте к этому размер стека, необходимый
для вашего кода обработчика прерываний - и
вы  получите необходимый размер стека. При
установках  по  умолчанию  размер стека не
должен превышать 62 байта!

ZXA_IS_DRAW.  В этой переменной содержится
#01, если  в данный момент идет распаковка
кадра и #00 в любом другом случае.

ZXA_QFRAMES. Эта переменная содержит номер
последнего  существующего  кадра анимации.
Всего,  как  я уже говорил, может быть 256
различных кадров произвольно расположенных
в  памяти.  Их  можно  регистрировать  под
любыми  номерами,  даже  образуя  "дыры" в
таблице кадров. И распаковывать можно кадр
с  произвольным  номером  -  в случае чего
будет  просто  распакован  пустой кадр. Но
лучше   всего   регистрировать   фрагменты
последовательно  - тогда в этой переменной
будет храниться общее число кадров.

ZXA_PAGE. В этой переменной задается номер
страницы  памяти,  в  которой  расположена
анимация. Эта переменная существует только
если   ZXA_LARGE_ANIMATION=NO,   т.к.  для
анимаций  из  нескольких фрагментов она не
имеет  смысла.  Не забывайте заносить туда
номер  страницы, если  ваша анимация лежит
не в нижней памяти!

   6.3 Проигрывание нескольких анимаций

 Если  у вас есть несколько анимаций, и вы
хотите  проиграть  их  все, используя один
плеер,  то  вы  должны выполнить несколько
условий:
 1. Как  вы  понимаете,  все  эти анимации
обязаны быть одного типа т.к. одновременно
в  ZXA  library  можно использовать только
один плеер.
 2. Если  это  обычные  или  чересстрочные
анимации, то перед проигрыванием каждой из
них  вам необходимо будет инициализировать
код  плеера  заново, вызывая ZXA_INIT. Это
необходимо,  т.к.  размер  окна  кадра для
каждой анимации может быть разным. Для C64
like  анимаций,  для которых размеры кадра
задаются  непосредственно  в  коде  это не
поможет - для них необходимо чтобы размеры
кадра у всех анимаций были одинаковыми.
 3. Если  анимация  состоит  из нескольких
фрагментов  -  размер кадра для каждого из
них  обязан  быть одинаковым! Это касается
всех типов анимаций.
 Как  добиться того чтобы размеры кадров у
разных анимаций были одинаковыми - читайте
в описании упаковщика.

              7. Заключение

 Ну вот и все. Надеюсь, что эта библиотека
пригодится  вам в ваших программах. Причем
это совсем необязательно должны быть демы,
кто  мешает,  допустим,  оформить переходы
между уровнями вашей игры простенькими, но
симпатичными анимациями.
 Но я хочу предупредить вас о двух вещах:
 1.  Не  стоит  увлекаться анимациями. Ими
можно  разнообразить  вашу  программу,  но
делать ставку только на анимацию не стоит.
 Кто-то  может обвинить нас в том, что мы,
отчасти, стали зачинщиками теперешней моды
на использование анимаций, а теперь еще, в
довершение  всего выпустили библиотеку для
проигрывания анимаций. Возможно это и так,
но  то,  что при умелом использовании дает
положительный   результат,   может  дать и
результат совершенно противоположный. Если
мы  использовали анимации - значит считали
это необходимым для демы, а вовсе не из-за
того что у нас не хватало сил написать еще
пару  эффектов. А если кто-то использует в
деме  анимации  только  ради анимаций - то
это уже не демомейкинг.
 2. Не забывайте что алгоритм упаковки, на
котором  основана  данная  библиотека  был
разработан  специально для упаковки строго
одного типа анимаций!
 Я  ни  в  коем  случае  не  претендую  на
позиционирование   этого   алгоритма   как
универсального.  Так  что  вам,  по любому
придется  использовать  его только для тех
анимаций,  на  которые  этот  алгоритм был
рассчитан    изначально.    За    качество
упаковки  всех  остальных видов анимаций я
не поручусь, более того я почти уверен что
качество  их  упаковки будет невысоким. Из
того,  что я видел, лично мне по качеству,
степени  компрессии и скорости больше всех
понравился VideoCruncher by Konex/ATS. Но,
к  сожалению, его алгоритм и/или исходники
Konex  не  пожелал  (возможно,  лишь пока)
сделать достоянием общественности. Так что
между  VideoCruncher'ом и ZXA library есть
одно  важное  отличие  в пользу последней:
ZXA  library  свободно  распространяется в
исходных текстах и с полным описанием. Так
что   пока  все  остальные  авторы  крутых
плееров   анимаций   раскачиваются  -  вам
придется пользоваться тем, что есть.
 Есть  еще  мнение  отдельных  людей,  что
распространение  исходных текстов повлечет
за собой появление кучи одинаковых, никому
не  нужных  программ  от разных ламеров не
умеющих  написать  что-то  свое.  По этому
поводу  я  могу сказать только одно: ламер
просто  не  сможет  использовать  эти (или
любые другие) исходники просто потому, что
его уровня развития на это не хватит. Зато
человеку  более  опытному наличие подобных
исходников  позволит  сэкономить  время  и
силы  и  позволит заняться не изобретением
велосипеда,  а оттачиванием  внешнего вида
своей программы.
 Так  что те, кому это понадобится, смогут
использовать  готовую библиотеку для своих
нужд. Другие смогут на ее примере увидеть,
как  можно создавать на Speccy полноценные
библиотеки. Третьи смогут, возможно, найти
что-то  новое или полезное для себя в коде
библиотеки. Вообщем многим людям она будет
полезна,  и  хотя  бы ради этого ее стоило
сделать и выпустить в свет.