Из газеты Optron #14, Львов, 04.07.98



    +====----
    |
    |    Kempston mouse (part II)    |
                                     |
                             ----====+

(C) Рашпиль

  В  прошлый  раз, вы, уважаемые читатели,
познакомились    со    схемой   интерфейса
кемпстон мышки.
  Сегодня я расскажу, чем же является мыш-
ка  для  программиста  - как определить ее
наличие, как работать с кнопками и коорди-
натами.


   --== Определение наличия мышки ==--


  Прежде  чем программно обрабатывать сиг-
налы,  идущие  с мышки, необходимо опреде-
лить,  а  есть ли мышка вообще. Существует
два  способа определения наличия мышки - с
помощью  порта  кнопок  и с помощью портов
координат.
  Перед  тем, как мы углубимся в кодинг, я
хочу   сделать   одно  замечание.  Если  в
компьютере реализован порт #FF (порт атри-
бутов),  то  он может конфликтовать с мыш-
кой, поэтому рекомендуется обрабатывать ее
порты  в те моменты времени, когда в порте
атрибутов находится значение #FF. Это про-
исходит  тогда,  когда  контроллер дисплея
строит  бордюр.  Очень удобно использовать
время,  когда  строится  верхний  бордюр -
примерно  12-14  тыс. тактов после прихода
INT'а. Этого времени вполне достаточно для
обработки координат и кнопок мышки, опроса
клавиатуры и проигрывания музыки.
  Так  как  же  определить, есть мышка или
нет?
  Первый  способ.  Во  многих программах я
встречал такой вариант определения наличия
мышки: считывается значение из порта одной
координаты (не важно какой) и сравнивается
со  значением  второй координаты, если они
не  равны,  то  мышка есть. Программно это
можно выразить так:

      EI
      HALT         ;ждем начала
                   ;построения бордюра
      LD BC,#FBDF
      IN L,(C)     ;читаем координату X
      LD B,#FF
      IN A,(C)     ;сравниваем с Y
      CP L
      JR Z,нет     ;если равны, то мышки
                   ;нет
есть  .....

  У  такого  способа,  на мой взгляд, есть
один  недостаток:  если вы только включили
компьютер  и не двигали мышку, то из счет-
чиков  будут считываться одинаковые значе-
ния  -  #FF, и программа будет думать, что
мышки  нет. Также не следует исключать ве-
роятность  того,  что  в процессе работы в
счетчиках  не установятся равные координа-
ты.  Вероятность такого совпадения - 1/256
(почему  именно столько - догадайтесь сами
;))
  Второй  способ  встречается также часто,
как и первый. Суть его в следующем: считы-
вается значение из порта кнопок и если там
не  ноль,  то  считается,  что мышка есть.
Тут, правда, может возникнуть вопрос: если
какой  либо порт не реализован, то из него
будет  читаться  #FF, и тогда, если интер-
фейса  мышки  нет,  то программа подумает,
что он все же есть. Ан нет. В таком случае
будет прочитано значение из порта джойсти-
ка - #00, поскольку для дешифрации и мышки
и джойстика, в отсутствии мышки, использу-
ется  разряд  A5 шины адреса процессора. А
если  нет и джойстика, то пускай программа
думает,  что  мышка  есть - это не мешает!
Ведь  значения в портах мышки нельзя никак
изменить.  Гораздо  хуже,  когда программа
думает,  что есть мышка, когда ее на самом
деле  нет.  При  этом начинают приниматься
значения из порта джойстика за значения из
какого-нибудь порта мышки. Начинаются лож-
ные  срабатывания  кнопки  FIRE  и бедному
юзеру ничего не остается, кроме как нажать
RESET.

      EI           ;думаю, все и так
      HALT         ;понятно
      LD BC,#FADF
      IN A,(C)     ;читаем порт кнопок
      OR A         ;и проверяем
      JR NZ,нет
есть  .....


        --== Обработка кнопок ==--


  Порт  кнопок весьма прост - #FADF, а его
раскладка еще проще:

  D0 - левая кнопка
  D1 - правая кнопка
  D2 - средняя кнопка

  Если  разряд установлен в "0", то кнопка
нажата.
  Тут  есть еще одно замечание. До сих пор
нет  единого мнения о том, какае биты при-
надлежат  левой  кнопке, а какие - правой.
Одни  придерживаются именно такой расклад-
ки, а другие - совершенно противоположной:
D0 - правая кнопка, D1 - левая. Почему так
получилось  я  не знаю. Но такое положение
вещей очень усложняет жизнь юзеру: в одной
программе все делается правой кнопкой, а в
другой  -  левой,  - неудобно! Кроме того,
пользователь может быть левшой.
  Чтобы такие проблемы не возникали, умные
дяди  придумали такую вещь, как автоконфи-
гурация  кнопок мышки. Суть проста: первая
нажатая  кнопка становится кнопкой выбора,
а другая (противоположная) - кнопкой отме-
ны. А вот и пример реализации:

;после выхода разряды D4-D6 регистра C
;будут содержать в информацию о
;том, какие кнопки нажаты ("1" - кнопка
;нажата
;D6 - средняя кнопка
;D5 - кнопка отмены
;D4 - кнопка выбора

      LD A,#FA     ;прочитали порт
      IN A,(#DF)   ;кнопок
      CPL          ;проинвертировали
      AND 0
MICEP EQU $-1

;при определении наличия мышки сюда
;подставляется #00, если мышки нет и #FF,
;если есть

      LD B,A
      AND 4        ;выделяем разряд
                   ;средней кнопки
      ADD A,A      ;задвигаем его в D6
      ADD A,A
      ADD A,A
      ADD A,A
      LD C,A
      JR CBUT      ;переход на процедуру
BUT_S EQU $-1      ;автоконфигурации

;процедура конфигурации вызывается только
;в том случае, если кнопки еще не
;нажимались
;определив кнопки, процедура изменяет
;смещение для команды перехода

      LD A,B
      AND 0        ;сюда подставляется
M_BUT EQU $-1      ;маска для выделения
                   ;разряда кнопки выбора
      CP 1         ;заполняем регистр
      CCF          ;A соответствующим
      SBC A,A      ;разрядом
      AND #10      ;выделяем D4
      OR C
      LD C,A       ;кладем в C
      LD A,B       ;аналогично поступаем с
      AND 0        ;кнопкой отмены
S_BUT EQU $-1
      CP 1
      CCF
      SBC A,A
      AND #20      ;в D5
      OR C
      LD C,A
NO_BUT
      RET          ;выход

;процедура автоконфигурации кнопок

CBUT
      LD A,B
      AND 3        ;кнопки не нажаты?
      JR Z,NO_BUT  ;если да, то выход
      RRA
      JR NC,$+4    ;разряд, отвечающий
      LD A,0       ;нажатой кнопке будет
      RLA          ;маской для выбора
      LD (M_BUT),A ;основной кнопки
      XOR 3        ;инвертируем маску
      LD (S_BUT),A ;маска кнопки отмены
      XOR A        ;изменяем смещение
      LD (BUT_S),A ;в команде перехода
      JR BUT_S+1   ;возврат


      --== Обработка координат ==--


  Наличие двух независимых восьмиразрядных
счетчиков    -   наибольшее   преимущество
кемпстон  мышки перед всеми другими. Счет-
чики все время считают координаты и мы мо-
жем  опрашивать  их в любой момент времени
(хоть десять раз за прерывание, хоть раз в
секунду). При обработке координат поступа-
ют следующим образом: в самом начале рабо-
ты  с  драйвером  запоминаются  координаты
мышки  и  при каждом обращении к ней нахо-
дится  разница между новым и старым значе-
ниями,  что, собственно, и будет смещением
курсора  на  экране;  только что считанные
значения  счетчиков подставляются на место
старых и цикл можно повторять.
  Адреса портов координат, как я уже гово-
рил,  следующие:  #FBDF  -  координата  X,
#FFDF - координата Y.


           --== Заключение ==--


  Ну,  вот и все. Если возьметесь за напи-
сание  драйвера,  то, пожалуйста, не забы-
вайте  о двух важных вещах: проверка нали-
чия мышки и автоконфигурация кнопок. А ес-
ли  возникнут  вопросы, то звоните: (0322)
67-60-45, Владимир.