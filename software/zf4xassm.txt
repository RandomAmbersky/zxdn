Из журнала ZX Format #4,
Санкт-Петербург, 15.06.1996



+---------------------------------------+
|      Xas редактор-ассемблер 128k      |
+---------------------------------------+
                (v 5.05)
(C) Макс Петров
__________________________________________

  Предлагаю Вам описание последней версии
программы, в журнале же Вы увидите преды-
дущую,  отличия которой оговорены и обоз-
начены значком "*".

         1. Вводная информация.

   1.1 Что такое, зачем надо и почему.

  Сейчас, как известно, для нашего много-
страдального, но любимого друга существу-
ет несколько подобных программ с бесспор-
ным лидером  Tasmом  (есть  ещ  какой-то
Zxasm,  но я его  не видел).  Однако Tasm
уже  с момента своего появления  отталки-
вал некоторых юзеров (меня) своей 64-сим-
вольностью,  а сегодня  вообще устарел со
своей overностью и букетом глюков. Собст-
венно вот  и вся  причина  появления моей
программы, за что спасибо Rst 7.
  Основываясь на опыте работы в Tasmе, на
котором  и писалась  первая версия  прог-
раммы,  а также  на собственных мечтах  и
пожеланиях  VL, IK и AB, получилась такая
штука:

 - ассемблирование в 4.4 раза быстрее
   Tasm 3.x.
 - дисковые операции в 2-3 раза быстрее,
   при большом количестве файлов на дис-
   кете - до 10-20 (!) раз.
 - поиск в тексте - почти мгновенный (со-
   ответственно в 20-30 раз (!)).
 - буфер на 1820 меток (* 1500) (tasm -
   740).
 - редактирование двух текстов одновре-
   менно с возможностью переноса блоков
   из одного текста в другой.
 - текст программы в 1.79 раза меньше,
   чем аналогичный в tasm.
 - количество кнопок, которые необходимо
   нажать для набора одного и того же
   текста в 1.333...1.5 раза меньше.
 - объм текста, который может быть отас-
   семблирован без единого обращения к
   дисководу - в 2.23 раза больше, чем
   в tasm (!).
 - максимальный объм одного текста в
   1.12 раза больше чем в tasm.
 - время, уходящее на поиск строки, со-
   держащей ошибку, которая выявилась
   при ассемблировании - в 50..1000 раз
   меньше ;).

 - работа с половинами ix и iy;
 - возможность ассемблирования выделенно-
   го участка n-е число раз (* - нет);
 - макросы,  которые в любой момент можно
   отредактировать;
 - большие русские и большие  и маленькие
   латинские буквы;
 - режимы ins и ovr;
 - 42 символа в строке;
 - сохранение  текущей  позиции  в тексте
   при любых операциях;
 - автотабуляция;
 - загрузка по курсору;  время загрузки и
   записи  не зависит от кол-ва файлов на
   дискете  (чего не скажешь о Tasme, ко-
   торый при работе с диском с 40-ка фай-
   лaми просто засыпает);
 - называется Xas [ksas];
 - много удобных, неожиданных, новых
   вещей...

  недостатки:
 - нет merge; (но с лихвой окупается воз-
   можностью переноса  помеченного  блока
   текста из одного окна в другое);
 - нет замены при find;
 - метки до 7 символов (остальные символы
   при ассемблировании игнорируются),
   (Tasm - до 14);
 - defb не любит стрингов;
 - глупенький equ  (в выражении не должно
   быть неопределнных меток);


         1.2 Загрузка и запуск.

  На диске находятся два файла: сам xas и
(должен быть  записан сразу  за ним)  sts
3.21.  Если Вы вышли из xasa в basic,  то
вернуться обратно можно выполнив run, ес-
ли  жива  программа  на  бейсике  (первую
строку можно удалить), usr 23465, если Вы
не  трогали  буфер  принтера  по  адресам
23465-23471 или usr 49152, включив банк 1
(out 32765,81).


       1.3 Расположение в памяти.

  Ramtop устанавливается  на адрес 24575,
но его можно  переставить  в любые адреса
до 32768.  Xas находится  в странице 1, в
странице 3 - первый текст,  в 4-ой - вто-
рой текст,  в 6-й макрос, таблица меток и
буфер для блочных операций,  в 7-oй стра-
нице находится sts.  При входе/выходе  из
xasa так же используется память в адресах
23440-23471. Вы можете использовать стра-
ницу 6 (даже убив макрос), а так же стра-
ницу 4,  если  не будете загружать  в не
второй  текст,  и  если  в ассемблируемой
программе нет опций loadtext.
  Кстати, следует сказать, что loadcode и
save code  пользуются   экранной  памятью
stsа (т.е. банком 7).
  В общем-то  можно изгадить и 3-й банк -
к зависанию это не приведт.
  И естественно, в Вашем распоряжении вся
48-я  память  (страницы 0, 2 и 5),  кроме
некоторых системных переменных бейсика.
  Если у Вас 256/512к через порт #fd биты
6 и 7, то используется 2й банк 128к (т.е.
#10 банк вместо 0,  #17 - 7-ого...),  что
обычно приводит к сохранению текста в па-
мяти даже после нажатия reset...


             2. Ввод текста.

              2.1 Загрузка.

  При любых операциях с диском смена цве-
та бордюра означает ошибку чтения/записи.
После четырх попыток, выдатся запрос:
Error t/s. Retry, Ignore, Abort.
где t/s- номер дорожки/сектора с ошибкой.
  При ответе  Retry  будет сделано ещ 14
попыток... Прерывание операции с диском -
- space.

  При запуске редактора-ассемблера (далее
р-а),  если  в памяти  нет текста,  то на
диске ищется файл  XMACROS.XaS (макрос) и
загружается  в случае  наличия  (и отсут-
ствия  в памяти).  Затем,  если  на диске
имеются файлы с расширениями  XAS, xAS  и
XaS,  перед  Вами появится  их списочек и
количество  свободных  на диске секторов.
Вы  можете выбрать нужный файл  с помощью
курсорных клавиш и enterа,  или отказать-
ся от загрузки,  нажав  edit  (отмена за-
грузки)  или ext mode (удаление текста из
памяти).  Space  - перезачтение каталога.
Если  файлов  на диске нет,  то р-а сразу
выйдет в редактор.


               2.2 Экран.

  Войдя в редактор, вы увидите несколько
буковок и цифирок внизу экрана.
INS - означает, что включн режим вставки
      (CS/3), OVR - замены;
LAT - выбран латинский алфавит (edit),
      РУС - русский;
0/1 - первое число показывает номер теку-
      щей строки (с нуля), второе - коли-
      чество строк в тексте  (т.е. макси-
      мальное  значение  для первого чис-
      ла).  В тексте  не может быть менее
      двух строк;
самое  -  показывает  номер текущего тек-
правое   ста:  1 - текст в банке 3, 2 - в
число    банке 4  и 3 - макрос в банке 6.
         Цвет цифры означает следующее:
        белый -  Вы ещ  не редактировали
         текст после загрузки,
        жлтый -  текст ещ не редактиро-
         вался после записи,
        красный - текст уже редактировал-
         ся,  и при следующей записи  его
         на диск  увеличится число, пока-
         зывающее кол-во редакций;
число, которое  - кол-во редакций текста,
находится перед   если  оно   равно  нулю
правым числом     (новый текст  или толь-
                  ко  что  перекодирован-
                  ный), то оно не показы-
                  вается.

Внизу находится строка из 29-ти символов.
Это комментарий, который хранится в текс-
те.
  В третьей снизу строке часто напечатана
модель для поиска (* - нет).

             2.3 Редактор.

  Довольно хитрая вещь:  при попытке вый-
ти за пределы строки он е упакует,  про-
верит элементарный синтаксис и,  если вс
в порядке,  сделает  автотабуляцию  (т.е.
строка вида
  LabEL    lD  Hl     #4000    ;МДААА ..
превратится в
label   LD    HL,#4000;МДААА ..
  При синтаксических ошибках как то:  две
метки подряд в начале строки, использова-
ние имн регистров  и условий  в качестве
меток,  более 3-х меток  в строке  (у z80
нет команд с четырьмя параметрами) (к de-
f-ам ограничение не относится),  редактор
что-то  пропищит  и никуда уйти не позво-
лит.
  Будте  осторожны  при  вводе  вложенных
друг в друга ковычек в defm:  если  у Вас
две рядом стоящие ковычки,  то  после них
рекомендую продолжать  ввод  со следующей
строки:  например нужен текст: "a""b" его
следует набрать не defm ""a""b"", а
defm """
defm "a"""
defm "b""



           Операции в строке:

ext mode - выход из редактора;
ss/q     - рус/lat;  расположение русских
           букв 'яверты' как в is_dos;
ss/a     - табуляция (самая редко исполь-
           зуемая кнопка);
cs/2     - ovr/ins;
edit     -home/end (начало/конец строки);
cursor   - курсор;
graph    - префикс макроса (см. ниже);
delete   - догадайтесь; если нажать в на-
           чале пустой строки,  то строка
           удалится;
break    - удаление по курсору;
ss/w     - удаление строки;
ss/enter - восстановление строки; возвра-
           щает строке вид,  который  она
           имела до редактирования;
ss/e     - пометка   строки  для  блочных
           операций;  не  обязательно ме-
           тить   строки  подряд;   чтобы
           снять пометку, нажмите повтор-
           но,  отметте  другим видом по-
           метки (см. cs/ent) или нажмите
           enter; (см. также ss/s);
cs/ent   - пометка   строки  для  памяти,
           этой же  пометкой метит строку
           ассемблер,  если в ней обнару-
           жена  ошибка;  снять пометку -
           - см. ss/e;

           Операции в тексте:

cs/3/4   - страница вверх/вниз;
ss/g     - начало/конец текста;
ss/y/u   - найти предыд./след. помеченную
           строку; если таких нет, ничего
           не происходит;
ss/s     - отмена пометки;
ss/f     - поиск  следующей модели;  если
           такой  нет,  то  меняется цвет
           бордюра; (см. ниже find);
graph ent - поиск  с _начала текста_ сло-
           ва,  на котором  стоит курсор;
           очень удобная вещь  для поиска
           меток;  не обязательно ставить
           курсор  на начало  слова - это
           будет сделано автоматически;
           для  поиска  следующего такого
           слова нажимайте ss/f;

           Блочные операции:

ss/d     -удаление помеченных ss/e строк;
ss/i     - копирование  помеченных   ss/e
           строк;  если  помеченных строк
           нет,   то  происходит  вставка
           текста из буфера;
graph ss/i - копирование помеченных строк
           в буфер, например, для перено-
           са их в другой текст;

(* - несколько  другое  расположение кла-
вишь:  edit - рус/lat; cs/2 - tab; cs/3 -
ovr/ins;  cs/4 - home/end; ss/q/a - pgup/
/pgdw).

 Чтобы скопировать строки из одного текс-
та в другой,  надо сначала поместить их в
буфер. Помеченные строки помещаются в бу-
фер при нажатии ss/i или graph ss/i.  За-
тем следует перейти  в другой текст  (за-
грузить его  или просто переключиться  на
другое окно), убрать в нм жлтую пометку
(ss/e) и нажать ss/i.

  При ассемблировании  с большим количес-
твом меток они могут наехать на буфер.
 (* при ассемблировании буфер очищается)


            2.4 Команды Xas.

   При нажатии ext в редакторе вы попада-
ете в командную строку. Вернуться в реда-
ктор можно нажав ext.  Команды выбираются
нажатием соответствующих клавиш:

aUto     (соответственно - 'u') отмена/
         /включение   необходимости  под-
         тверждения  выбора команды ente-
         rом (эта команда, на самом деле,
         рудимент,  и в след.  версиях е
         не будет,  так что наслаждайтесь
         сейчас);
Edit     возврат в редактор;
Sаve text запись текста на диск;  предла-
         гает сменить имя;  во время вво-
         да имени команду можно отменить,
         нажав ext,  при  этом  изменение
         имени сохраняется; если на диске
         такой  файл есть,  он удаляется;
         если на диске нет места, сообще-
         ний  не выдатся,  меняется цвет
         бордюра на красный.

Load text загрузка файла по каталогу; ес-
         ли на диске нет файлов  с типами
         XAS, XaS, xAS или xaS,  то ката-
         лог  не появляется и xas возрва-
         щается  в командную строку;  при
         выборе файла  работают следующие
         клавиши:  space  -  перезачтение
         каталога,  edit - отмена загруз-
         ки, ext - удаление текста из па-
         мяти; файлы, начинающиеся с сим-
         вола '#' - удалнные, но их мож-
         но свободно загрузить; тип файла
         'Т' означает текст, 'М' - макрос
         (он автоматически загружается  в
         окно 3, независимо от текущего);
sTs      выход в sts (* - нет);
         при нажатии cs/t  в pc будет за-
         писан адрес старта отассемблиро-
         ванной программы,  а  в memadr -
         последнее напечатанное в кальку-
         ляторе число (для sts 4.x);
Quit     выход в basic, который вс равно
         запускает sts;
Find     ввод модели для поиска по ss/f и
         поиск  первой  с начала  текста;
         ext  - отмена редактирования мо-
         дели и поиск старой модели;  при
         вводе модели  надо  учесть,  что
         если вводимые слова не ограниче-
         ны ковычками  и не являются ком-
         ментарием,  то, если они являют-
         ся именами операций  или операн-
         дов,  то  будут  найдены  именно
         операции и операнды; это значит,
         что для поиска регистра "А" сле-
         дует набрать "А",  для поиска же
         буквы "А" (регистр найден не бу-
         дет), надо ввести ";А";  пример:
         ввели "IN"  - будут найдены  все
         операции "IN"; ввели ";IN" - все
         слова,  включающие  "IN"  (но не
         операции IN);
         если надо найти слово, не являю-
         щееся именем ком. или опер.,  то
         символ ";" вводить не надо; если
         надо найти модель,  начинающуюся
         с символа  ";",  то надо  ввести
         ";;";  при поиске меток  и чисел
         вводите  их _большими буквами_;
Run      запуск  отассемблированной прог-
         раммы с последнего ent или, если
         entов нет, с последнего org или,
         если  orgов нет,  с #8000;  если
         программа собирается вернуться в
         xas,  то  она  не должна портить
         память по адресам 23465 - 23471,
         системные переменные,  связанные
         с потоком N 2 и заканчивать свою
         работу операцией ret;
         cs/r - после  возврата  из прог-
         раммы  и до очистки экрана будет
         ожидаться нажатие любой клавиши;
remarK   редактирование комментария;
Assemble ассемблирование;
fullCat  полный  каталог  диска; cs/c -
         все данные выводятся  в десятич-
         ном виде;
neW      удаление текста из памяти;  надо
         подтвердить 'Y';
laBels   вывод  на экран  таблицы  меток,
         отсортированной  по первому сим-
         волу;  для  прерывания   нажмите
         space;  если после ассемблирова-
         ния Вы пользовались блочной опе-
         рацией 'копирование' и меток бы-
         ло очень много, то Вы увидите не
         все метки;
         cs/b - печать в десятичном виде;
         (* -  не поддерживает  нажатие с
         cs,  а задат вопрос 'hex?',  на
         который надо ответить 'n',  если
         нужна печать в десятичной систе-
         ме);
save cOde -  запись объектного кода;  при
         длине кода более #c000 запись не
         производится, т.к. таких длин  в
         памяти 48k не бывает;
Mac edit - редактирование файла макросов,
         который находится в 3-ем окне;
aNother  - переключение на редактирование
         другого окна: 1>2, 2>1, 3>1;
comPute  -  калькулятор.  Можно  набирать
         выражения  как  и в тексте прог-
         раммы  (имена меток,  двоичные и
         символьные константы..), резуль-
         тат будет  напечатан  в десятич-
         мой  и  шестнадцатиричной систе-
         мах; калькулятором можно пользо-
         ваться для перевода чисел из од-
         ной системы в другую,  просмотра
         значений меток,  установки адре-
         са sts  на значение  метки  (см.
         sTs) (* - нет);

          3. Ассемблирование.


   Ассемблирование  в два прохода,  но не
традиционное. На первом проходе составля-
ется таблица меток. По окончании его поя-
вится сообщение о длине и конце объектно-
го кода.
   Почти все ошибки объявляются на втором
проходе.  Ассемблирование  можно прервать
на втором проходе, нажав cs.  Второй про-
ход заканчивается звуковым сигналом.  Те-
перь программу можно запустить  (см. run)
или записать на диск (save code).
   Хочется заметить,  что время ассембли-
рования  в основном зависит от количества
меток, а от, скажем, длины текста  - зна-
чительно меньше. Отсюда очень простой вы-
вод: делайте меньше меток,  и формула для
примерного вычисления времени ассемблиро-
вания: t=0.000163*n^1.72, где t - время в
секундах, а n - кол-во меток.


              3.1 Ошибки.

   При обнаружении ошибки  на экран выво-
дится строка с ошибкой,  ниже - е номер,
название ошибки и, если текст загружается
loadtextом или просто находится во второй
странице, его имя.  При этом строка поме-
чается красным цветом (см. cs/ent), чтобы
е можно было легко найти  и отредактиро-
вать ((c) мой).

   Список ошибок:

No Label   - нет такой метки;
Syntax In Number  - синтаксическая ошибка
             в числе;
Label Exists - выдатся  на первом прохо-
             де; метка с таким именем уже
             существует (см. введение);
Syntax     - синтаксическая ошибка  в па-
             раметре  операции  (например
             (ix+));
Target Too Far  - операция jr или djnz не
             может прыгнуть так далеко;
Number Too Big -в операциях, не связанных
             с (ix/iy+d)  - просто преду-
             преждение,   что  параметром
             является число,  превышающее
             допустимое для данной опера-
             ции  (например, bit 3+15,a),
             при этом будут взяты младшие
             разряды числа;  в  параметре
             же для (ix/iy+d) может озна-
             чать ошибку;
Fatal Error - обычно  ошибка  в параметре
             операции,  которая исключает
             возможность е ассемблирова-
             ния (ld sp,bc);
LTB Over   - нет больше  места  в таблице
             меток;  появляется на первом
             проходе  и останавливает ас-
             семблирование;
No File    - нет файла в командах loadco-
             de и loadtext;
Skipping   - предупреждение  об игнориро-
             вании команды loadtext, если
             она встретилась  в тексте во
             втором окне (см. ниже)
             или команды  loadcode,  если
             файл отсутствует  (на втором
             проходе);
             предупреждение  о  вложенном
             !assm;

 Внимание! При ошибках Fatal Error объек-
тный код является настолько некорректным,
что  его  использование  невозможно  (это
связано с невозможностью определения дли-
ны операции в байтах,  что приводит к не-
правильному составлению таблицы меток.
Другие р-а при подобных ошибках вообще
останавливают ассемблирование.



          3.2 Текст программы


  Текст можно набирать маленькими и боль-
шими буквами, с или без табуляторов, вме-
сто запятых можно набирать пробелы (кроме
def-ов). Маленькие буквы набираются с cs.
Макросы набираются нажатием graph и затем
какой-либо клавиши.  При попытке выйти за
пределы строки, она будет перекодирована,
пробелы,  где  надо,  заменены  запятыми,
метки для повышения читабельности (может,
сначала  Вам это будет мешать,  но затем,
надеюсь,  Вы оцените мои старания)  будут
напечатаны  маленькими  буквами.  Если  в
строке есть ошибки,  Вы  не сможете выйти
за е пределы, не исправив е.
 Русские буквы нельзя использовать в мет-
ках.
 Вместо (ix/iy+0) можно набирать (ix/iy);
половинки ix/iy обозначаются hx/y и lx/y.
 В ex af,af' апостроф можно не ставить.
 При наборе шестнадцатиричных чисел вмес-
то значка '#' можно нажимать '.'.
 В операциях
ld (adr),rp ld (adr),a out (n),a in a,(n)
скобки ставить не обязательно (т.е. можно
ld l01+50/3,de).
 В out (c),r и in r,(c) '(c)' можно опус-
кать (out l). (* - нет)
  Несколько push или pop подряд можно за-
менить одним, перечислив регистровые пары
через запятую: pop af:pop iy:pop bc =
pop af,iy,bc.


 Числа

  Вместо _любых_ чисел можно набирать вы-
ражения,  где   - буквы в ковычках - чис-
ло,  состоящее из кодов букв  (в ковычках
(кроме defm) могут быть одна или две бук-
вы),  причм первая буква - старший байт,
вторая  - младший.  Если  буква одна,  то
первый байт равен нулю;  - скобки  и пре-
оритет операций не поддерживаются;  - до-
пустимые операции: +,-,*,/ и ! - xor (на-
пример: "B"!#80; 1520!label1!#f001). Под-
держиваются  двоичние  числа,  они должны
начинаться со знака '%' и лежать в диапа-
зоне 0..65535.
 Ещ две логические операции:
&l - взять только младший байт,
&h - взять только старший байт,  поместив
     его в младший, т.е. #5cf4&h = #5c;
'l - циклический сдвиг результата влево,
'r - то же вправо, т.е. #a703'r = #d381.
  Если надо сдвинуть несколько раз, то
операцию надо просто продублировать.

    Особенности (def, work, ent, org,
             loadcode, loadtext, !assm)

 defs  - поддерживает до двух параметров;
если второго параметра нет,  то он прини-
мается  равным нулю.  Второй  параметр  -
- _двухбайтовое_ число, которым будет за-
полнять память defs. Примеры:
1) надо 15 нулей  -  defs 15
2) надо 31 push af - defs 31,#f5f5
3) надо 10,0,10 - defs 3,10
4) надо 32 ldi (ed a0) - defs 64,#a0ed

 work  -  позволяет  создавать программы,
работающие  не  с тех адресов,  в которые
они будут ассемблироваться.  Параметр оз-
начает адрес,  с которого  будет работать
данная  программа.   Распространяется  на
_всю_ программу  и _все_ orgи и сохраняет
сво влияние до опции work без параметра.
Рекомендую ставить е  в начале программы
_после_ orga. Пример: нужно отассемблиро-
вать программу для работы с адреса 0:
     org #9000
     work 0
lab1 .....
     org #a005
lab2 work
lab3 .....
   метка lab1 будет иметь значение #0000,
lab2 - #1005, а lab3 - #a005.

 ent  - позволяет указать адрес,  с кото-
рого будет запускаться программа командой
run. Используется без параметра.

 org  -  указывает текущий адрес для рас-
положения программы.   Если orga нет,  то
адрес будет равен #8000. Внимание! Если в
начале  Вашего текста  orgа нет,  но оrgи
есть дальше, и если они все больше #8000,
то длина  объектного кода будет вычислена
неправильно!  (не будет учтн org #8000).
Поэтому  если Вы желаете  воспользоваться
save code, то в данном случае надо поста-
вить в начале текста org #8000.

 loadcode "name"  - имя должно быть в ко-
вычках; грузится файл типа code;

 loadtext "name" - если во второй страни-
це уже есть файл с таким именем, то обра-
щения к диску не происходит!!!,  если  же
его нет,  то он  загрузится туда,  удалив
текст, который там был до этого.  Из вто-
рой страницы по понятной причине не рабо-
тает.  Если кто не знает, что такое load-
text - эта опция позволяет иметь програм-
му на ассемблере,  состоящую из множества
текстов, которые грузятся и ассемблируют-
ся  по очереди;  при этом  они пользуются
одной  таблицей меток,  поэтому  из одних
файлов можно без ограничений ссылаться на
метки из других файлов.

  !assm  !on/!off

  Eщ имеется  оригинальная опция  !assm,
которая  может  иметь  параметр  !on  или
!off. Она дат возможность выделять куски
текста,   которые  надо  отассемблировать
только один раз,  или вообще  не надо ас-
семблировать.  Параметр !on означает, что
опция !assm игнорируется, но после ассем-
блирования он будет переведн в !off.
!off  же вызывает пропуск текста до опции
!cont.  Пример: Вы пишите драйверок печа-
ти,  который пользуется  загружаемым фон-
том.  Так зачем же его загружать при каж-
дом ассемблировании?  Можно загрузить его
только один раз,  и потом он будет сидеть
в памяти:
...
font  org #7000
      !assm !on
      loadcode "font51"
      !cont
      org #7300
...
  или Вам не надо, чтобы ассемблировалась
какая-то часть кода,  и чтобы не забивать
все строки в комментарии, просто огранич-
те их опциями !assm !off и !cont.

 !assm n  (* - нет)

 Параметр n - кол-во повторов.  Позволяет
отассемблировать  кусок  текста  до опции
!cont n раз. Напоминает об defs Tasmа, но
на порядок круче е:

 !assm 128
 ld hl,0
 push hl
 !cont

 !assm #50/2-%0101
"i zachem eto?"
 ld hl,0
 call 1
 !cont

Вместо n может стоять метка, если она оп-
ределяется выше.
Ставить метки между !assm n  и  !cont  не
рекомендуется. Пользуйтесь $.

Вложенность !assm с любыми параметрами не
допускается!



defm - вместо  defm "string"  можно наби-
рать просто "string", в этом случае коли-
чество  символов  в строке  увеличится до
40.

defb - если в defb у  Вас только шестнад-
цатиричные числа, то можно вместо
defb #n1,#n2,#n3,#n4... набирать просто
#n1n2n3n4... Здесь первый символ '#' обя-
зателен и каждое число должно быть набра-
но двумя цифрами  (0=00, #a=0a...); числа
для наглядности  можно разделять значками
'#'  (#n1#n2n3#n4... - как угодно)  и ко-
нечно, вместо '#' можно жать '.'


               4  Макрос.

  Макросы набираются нажатием graph  (cs/
/9) и затем одной из клавиш с шифтами или
без.  При этом на экран выведется строка,
которая  присвоена файлом макроса  данной
букве.  Файл  макроса строится  следующим
образом:  он состоит из строк, где первым
символом должен стоять знак ';', вторым -
символ, при нажатии которого на экран бу-
дет выводиться строка, которая расположе-
на за этим вторым  (т.е. до 40 символов).
Если  в конце строки  необходимы пробелы,
то последний пробел  следует заменить  на
подчркивание (ss/0), иначе они будут об-
резаны редактором. Если надо, чтобы после
вывода  макроса  автоматически  нажимался
enter, заканчивайте макрос точкой.
  Длина файла макроса не должна превышать
#b20, чего, собственно,  вполне достаточ-
но,  чтобы иметь макрос на всех возможных
символах (их около 90). Ограничение длины
связано  с  таблицей  меток:  при блочной
операции копирования  макрос будет урезан
до указанной длины. Если в Вашей програм-
ме огромное количество меток  (>1500), то
файл макросов в памяти может быть частич-
но или полностью уничтожен, что, впрочем,
к подвисанию не приведт, просто, если Вы
пользуетесь макросами,  надо будет их пе-
резагрузить.


            5 Формат текста.

  Раздел для тех, кто хочет написать свои
перекодеровщики  и др. или разобраться  в
работе р-а...

 Первые 29 байт файла хранят комментарий;
затем 2 байта  - адрес текущей позиции  в
тексте  (адрес  _начала_ текущей строки);
далее 2 байта - текущие координаты курсо-
ра (x, потом y);  1 байт признак ovr/ins;
1 байт - кол-во редакций файла  (0..127);
байт #01 - признак начала текста.
Формат строки текста объясню на примере:

экран:
label   LD    HL,#4d00-" a"; ПРИМЕР
память:
'LABEL',#ac,#d2,'#4D00-" a"; ПРИМЕР',#0d

метки хранятся большими буквами;
табуляторы отсутствуют;
запятые могут быть только в комментариях,
ковычках  или  в качестве разделителей  в
defах;
пробелы могут быть только  в ковычках или
в комментариях;
последний байт  в строке может быть #0d -
строка обычного цвета,  #09 - жлтого или
#0c - красного;
такой пример:
         LD   (IX+"1"!2),"V"
в памяти: #аc,'(',#d3,'+"1"!2)V',#0d

  Русские буквы: схожие  по начертанию  с
латинскими в фонте не дублируются и имеют
коды латинских, остальные имеют коды:
ДЖИЙЛПУФЦЧЫЬЭЮЯЪ - с #10 до #1f, ШЩБГ - с
#7b до #7e.

 И самым последним байтом в тексте должен
стоять #00.



      6 Советы по программированию
                новичкам

 Может, конечно, это наглость с моей сто-
роны давать какие-либо советы, но вс-та-
ки я написал уже две серьзные программы,
так что кое-что могло бы Вам пригодиться.
1)  постарайтесь  спланировать  программу
перед  е написанием.  Точно решите,  что
она будет делать и как.
2) старайтесь делать меньше меток - и ас-
семблирование пойдт быстрее,  и не будет
проблем с переполнением таблицы - исполь-
зуйте значк '$',  который означает теку-
щий адрес; если рядом стоят несколько ме-
ток,  то можно обратиться к одной исполь-
зуя имя другой +/- смещение.
3) для экономии памяти пользуйтесь следу-
ющими вещами:  если вам нужна ячейка,  то
не делайте подобного:
label defb 0
....
ld a,(label)
....
ld (label),a
а заменяйте на:
label ld a,0

ld (label+1),a
  В качестве ячеек для хранения чего-либо
можно использовать переменные бейсика.
Для, например,  печати через свой драйвер
можно переопределить канал  и пользовать-
ся rst 16.
4) о быстродействии: помните,  что jp ра-
ботает быстрее jr,  ldi быстрее ldir, что
самый быстрый способ  запихнуть  в память
байт  или достать его оттуда  это push  и
pop.
5) о '$':  помните, что $ указывает адрес
начала текущей операции, т.е.
label djnz label
эквивалентно
      djnz $
a не, скажем, $-2.

            7 Перекодеровщик.

   Перекодеровщик написал  hacker Cris, и
вещь, я Вам скажу, довольно крутая: пере-
кодирует он из gens,  isdos assembler или
tasm 3.0  в xas  и из xasa  в txt, причм
формат текста (gens/isdos/tasm/xas) опре-
деляет сам,  так что думать вообще не на-
до.
   При перекодеровке в xas он пишет коли-
чество ошибок - переполнений строки (т.к.
в  tasme  и isdose строки  до 255(?), а у
меня до 42 символов, и длинные строки ре-
жутся пополам. При этом строка будет  по-
мечена  красным цветом  и е можно  легко
найти  в xasе  (по ss/y/u)  и подправить.
После перекодеровки может возникнуть глю-
чок:  при ассемблировании находится ошиб-
ка,  тогда как строка выглядит нормально.
Здесь надо просто встать  на эту строку и
нажать что-либо  отличное от курсор вверх
и вниз.  Например,  можно просто нажимать
ss/u или y.


               8 The End.

  Ну вс, закончена эта убойная работа по
набиванию helpа, теперь можно расслабить-
ся и сознаться,  что весь help и весь Xas
написал Макс Петров из Санкт-Петербурга в
январе 1996 года с телефоном 598 0159 (по
которому можно сообщить о глюках).
  А также сказать, что перекодеровщик на-
писал hacker Cris,  похоже не без  помощи
своего виртуального брата Johna Stunnera.
За что им спасибо,  т.к. во время писания
они поймали часть глючков в Xasе.  Johnnу
ещ одно спасибо за ускорение оч. малень-
кой,  но оч. важной процедурки, результа-
том которого стало повышение скорости ас-
семблирования  на  15% по сравнению с ис-
ходным,  а больше всего  я ему благодарен
за то,  что его ускорение навело меня  на
мысль о ещ большем ускорении,  и я полу-
чил ещ 32-х процентное уменьшение време-
ни ассемблирования... В результате счет в
нашу пользу увеличился в полтора раза.
  И наконец передать привет  и  пожелания
счастья в новом году всем юзерам,  плейе-
рам, хакерам и сочувствующим.





        Max Petrov (hpm) 01.96-05.96 SPb.
_________________________________________